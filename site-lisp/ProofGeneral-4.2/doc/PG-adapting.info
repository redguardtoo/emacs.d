This is PG-adapting.info, produced by makeinfo version 4.13 from
PG-adapting.texi.

INFO-DIR-SECTION Theorem proving
START-INFO-DIR-ENTRY
* Adapting Proof General: (PG-adapting).  Adapt Proof General to new provers
END-INFO-DIR-ENTRY
END-INFO-DIR-ENTRY


File: PG-adapting.info,  Node: Top,  Next: Introduction,  Up: (dir)

Proof General
*************

This file documents configuration mechanisms for version 4.2pre of
Proof General, a generic Emacs interface for proof assistants.

Proof General 4.2pre has been tested with GNU Emacs 23.3.  It is
supplied ready customized for the proof assistants Coq, Lego, Isabelle,
and HOL.

This manual contains information for customizing to new proof
assistants; see the user manual for details about how to use Proof
General.

* Menu:

* Introduction::
* Beginning with a New Prover::
* Menus and Toolbar and User-level Commands::
* Proof Script Settings::
* Proof Shell Settings::
* Goals Buffer Settings::
* Splash Screen Settings::
* Global Constants::
* Handling Multiple Files::
* Configuring Editing Syntax::
* Configuring Font Lock::
* Configuring Tokens::
* Configuring Proof-Tree Visualization::
* Writing More Lisp Code::
* Internals of Proof General::
* Plans and Ideas::
* Demonstration Instantiations::
* Function Index::
* Variable Index::
* Concept Index::


File: PG-adapting.info,  Node: Introduction,  Next: Beginning with a New Prover,  Prev: Top,  Up: Top

Introduction
************

Welcome to Proof General!

Proof General a generic Emacs-based interface for proof assistants.

This manual contains information for adapting Proof General to new proof
assistants, and some sketches of the internal implementation.  It is not
intended for most ordinary users of the system.  For full details about
how to use Proof General, and information on its availability and
installation, please see the main Proof General manual which should
accompany this one.

We positively encourage the support of new systems.  Proof General has
grown more flexible and useful as it has been adapted to more proof
assistants.

Typically, adding support for a new prover improves support for others,
both because the code becomes more robust, and because new ideas are
brought into the generic setting.  Notice that the Proof General
framework has been built as a "product line architecture": generality
has been introduced step-by-step in a demand-driven way, rather than at
the outset as a grand design.  Despite this strategy, the interface has
a surprisingly clean structure.  The approach means that we fully expect
hiccups when adding support for new assistants, so the generic core may
need extension or modification.  To support this we have an open
development method: if you require changes in the generic support,
please contact us (or make adjustments yourself and send them to us).

Proof General has a home page at `http://proofgeneral.inf.ed.ac.uk'.
Visit this page for the latest version of the manuals, other
documentation, system downloads, etc.

* Menu:

* Future::
* Credits::


File: PG-adapting.info,  Node: Future,  Next: Credits,  Up: Introduction

Future
======

The aim of the Proof General project is to provide a powerful and
configurable interfaces which help user-interaction with interactive
proof assistants.

The strategy Proof General uses is to targets power users rather than
novices; other interfaces have often neglected this class of users.  But
we do include general user interface niceties, such as toolbar and
menus, which make use easier for all.

Proof General has been Emacs based so far, but plans are afoot to
liberate it from the points and parentheses of Emacs Lisp.  The
successor project Proof General Kit proposes that proof assistants use a
standard XML-based protocol for interactive proof, dubbed PGIP.

PGIP enables middleware for interactive proof tools and interface
components.  Rather than configuring Proof General for your proof
assistant, you will need to configure your proof assistant to understand
PGIP.  There is a similarity however; the design of PGIP was based
heavily on the Emacs Proof General framework.  This means that effort on
customizing Emacs Proof General to a new proof assistant is worthwhile
even in the light of PGIP: it will help you to understand Proof
General's model of interaction, and moreover, we hope to use the Emacs
customizations to provide experimental filters which allow supported
provers to communicate using PGIP.

At the time of writing, these ideas are in early stages. For latest
details, or to become involved, see the Proof General Kit webpage
(http://proofgeneral.inf.ed.ac.uk/kit).


File: PG-adapting.info,  Node: Credits,  Prev: Future,  Up: Introduction

Credits
=======

David Aspinall put together and wrote most of this manual.  Thomas
Kleymann wrote some of the text in Chapter 8.  Much of the content is
generated automatically from Emacs docstrings, some of which have been
written by other Proof General developers.


File: PG-adapting.info,  Node: Beginning with a New Prover,  Next: Menus and Toolbar and User-level Commands,  Prev: Introduction,  Up: Top

1 Beginning with a New Prover
*****************************

Proof General has about 100 configuration variables which are set on a
per-prover basis to configure the various features.  It may sound like a
lot but don't worry!  Many of the variables occur in pairs (typically
regular expressions matching the start and end of some text), and you
can begin by setting just a fraction of the variables to get the basic
features of script management working.  The bare minimum for a working
prototype is about 25 simple settings.

For more advanced features you may need (or want) to write some Emacs
Lisp.  If you're adding new functionality please consider making it
generic for different proof assistants, if appropriate.  When writing
your modes, please follow the Emacs Lisp conventions, *note
(Elisp)Tips::.

The configuration variables are declared in the file
`generic/proof-config.el'.  The details in the central part of this
manual are based on the contents of that file, beginning in *note Menus
and Toolbar and User-level Commands::, and continuing until *note
Global Constants::.  Other chapters cover the details of configuring
for multiple files and for supporting the other Emacs packages
mentioned in the user manual (Support for other Packages).  If you
write additional Elisp code interfacing to Proof General, you can find
out about some useful functions by reading *note Writing More Lisp
Code::.  The last chapter of this manual describes some of the
internals of Proof General, in case you are interested, maybe because
you need to extend the generic core to do something new.

In the rest of this chapter we describe the general mechanisms for
instantiating Proof General.  We assume some knowledge of the content
of the main Proof General manual.

* Menu:

* Overview of adding a new prover::
* Demonstration instance and easy configuration::
* Major modes used by Proof General::


File: PG-adapting.info,  Node: Overview of adding a new prover,  Next: Demonstration instance and easy configuration,  Up: Beginning with a New Prover

1.1 Overview of adding a new prover
===================================

Each proof assistant supported has its own subdirectory under
`proof-home-directory', used to store a root elisp file and any other
files needed to adapt the proof assistant for Proof General.

Here is how to go about adding support for a new prover.

  1. Make a directory called `myassistant/' under the Proof General home
     directory `proof-home-directory', to put the specific customization
     and associated files in.

  2. Add a file `myassistant.el' to the new directory.

  3. Edit `proof-site.el' to add a new entry to the
     `proof-assistants-table' variable.  The new entry should look like
     this:
              (myassistant "My Proof Assistant" "\\.myasst$")
     The first item is used to form the name of the internal variables
     for the new mode as well as the directory and file where it loads
     from.  The second is a string, naming the proof assistant.  The
     third item is a regular expression to match names of proof script
     files for this assistant.  See the documentation of
     `proof-assistant-table' for more details.

  4. Define the new Proof General modes in `myassistant.el',  by
     setting configuration variables to customize the  behaviour of the
     generic modes.

 -- User Option: proof-assistant-table
     Proof General's table of supported proof assistants.
     This is copied from ``proof-assistant-table-default'' at load time,
     removing any entries that do not have a corresponding directory
     under ``proof-home-directory''.

     Each entry is a list of the form
            (SYMBOL NAME FILE-EXTENSION [AUTOMODE-REGEXP] [IGNORED-EXTENSIONS-LIST])
     The NAME is a string, naming the proof assistant.  The SYMBOL is
     used to form the name of the mode for the assistant,
     `SYMBOL-mode', run when files with AUTOMODE-REGEXP (or with
     extension FILE-EXTENSION) are visited. If present,
     IGNORED-EXTENSIONS-LIST is a list of file-name extensions to be
     ignored when doing file-name completion (IGNORED-EXTENSIONS-LIST
     is added to `completion-ignored-extensions').

     SYMBOL is also used to form the name of the directory and elisp
     file for the mode, which will be
              PROOF-HOME-DIRECTORY/SYMBOL/SYMBOL.el
     where PROOF-HOME-DIRECTORY is the value of the variable
     ``proof-home-directory''.

     The default value is `((isar "Isabelle" "thy") (coq "Coq" "v" nil
     (".vo" ".glob")) (phox "PhoX" "phx") (hol-light "HOL Light" "ml")
     (pgshell "PG-Shell" "pgsh") (pgocaml "PG-OCaml" "pgml") (pghaskell
     "PG-Haskell" "pghci"))'.

The final step of the description above is where the work lies.  There
are two basic methods.  You can write some Emacs lisp functions and
define the modes using the macro `define-derived-mode'.  Or you can use
the new easy configuration mechanism of Proof General 3.0 described in
the next section, which calls `define-derived-mode' for you.  You still
need to know which configuration variables should be set, and how to
set them.

The documentation below (and inside Emacs) should help with that, but
the best way to begin might be to use an existing Proof General instance
as an example.


File: PG-adapting.info,  Node: Demonstration instance and easy configuration,  Next: Major modes used by Proof General,  Prev: Overview of adding a new prover,  Up: Beginning with a New Prover

1.2 Demonstration instance and easy configuration
=================================================

Proof General is supplied with a demonstration instance for Isabelle
which configures the basic features.  This is a whittled down version of
Isabelle Proof General, which you can use as a template to get support
for a new assistant going.  Check the directory `demoisa' for the two
files `demoisa.el' and `demoisa-easy.el'.

The file `demoisa.el' follows the scheme described in *note Major modes
used by Proof General::.  It uses the Emacs Lisp macro
`define-derived-mode' to define the four modes for a Proof General
instance, by inheriting from the generic code.  Settings which configure
Proof General are made by functions called from within each mode, as
appropriate.

The file `demoisa-easy.el' uses a new simplified mechanism to achieve
(virtually) the same result.  It uses the macro `proof-easy-config'
defined in `proof-easy-configl.el' to make all of the settings for the
Proof General instance in one go, defining the derived modes
automatically using a regular naming scheme.  No lisp code is used in
this file except the call to this macro.  The minor difference in the
end result is that all the variables are set at once, rather than
inside each mode.  But since the configuration variables are all global
variables anyway, this makes no real difference.

The macro `proof-easy-config' is called like this:
        (proof-easy-config MYPROVER "MYPROVER"
             CONFIG_1 VAL_1
             ...
             CONFIG_N VAL_N)
The main body of the macro call is like the body of a `setq'.  It
contains pairs of variables and value settings.  The first argument to
the macro is a symbol defining the mode root, the second argument is a
string defining the mode name.  These should be the same as the first
part of the entry in `proof-assistant-table' for your prover.  *Note
Overview of adding a new prover::.  After the call to
`proof-easy-config', the new modes `MYPROVER-mode',
`MYPROVER-shell-mode', `MYPROVER-response-mode', and
`MYPROVER-goals-mode' will be defined.  The configuration variables in
the body will be set immediately.

This mechanism is in fact recommended for new instantiations of Proof
General since it follows a regular pattern, and we can more easily
adapt it in the future to new versions of Proof General.

Even Emacs Lisp experts should prefer the simplified mechanism.  If you
want to set some buffer-local variables in your Proof General modes, or
invoke supporting lisp code, this can easily be done by adding functions
to the appropriate mode hooks after the `proof-easy-config' call.  For
example, to add extra settings for the shell mode for `demoisa', we
could do this:
        (defun demoisa-shell-extra-config ()
           EXTRA CONFIGURATION ...
         )
        (add-hook 'demoisa-shell-mode-hook 'demoisa-shell-extra-config)
The function to do extra configuration `demoisa-shell-extra-config' is
then called as the final step when `demoisa-shell-mode' is entered (be
wary, this will be after the generic `proof-shell-config-done' is
called, so it will be too late to set normal configuration variables
which may be examined by `proof-shell-config-done').


File: PG-adapting.info,  Node: Major modes used by Proof General,  Prev: Demonstration instance and easy configuration,  Up: Beginning with a New Prover

1.3 Major modes used by Proof General
=====================================

There are four major modes used by Proof General, one for each type of
buffer it handles.  The buffer types are: script, shell, response and
goals.  Each of these has a generic mode, respectively: `proof-mode',
`proof-shell-mode', `proof-response-mode', and `proof-goals-mode'.

The pattern for defining the major mode for an instance of Proof General
is to use `define-derived-mode' to define a specific mode to inherit
from each generic one, like this:
     (define-derived-mode myass-shell-mode proof-shell-mode
        "MyAss shell" nil
        (myass-shell-config)
        (proof-shell-config-done))
Where `myass-shell-config' is a function which sets the configuration
variables for the shell (*note Proof Shell Settings::).

It's important that each of your modes invokes one of the functions
`proof-config-done',  `proof-shell-config-done',
`proof-response-config-done', or  `proof-goals-config-done' once it has
set its configuration variables.  These functions finalize the
configuration of the mode.

The modes must be named standardly, replacing `proof-' with the
prover's symbol name, `PA-'.  In other words, you must define
`PA-mode', `PA-shell-mode', etc.

See the file `demoisa.el' for an example of the four calls to
`define-derived-mode'.

Aside: notice that the modes are selected using stub functions inside
`proof-site.el', which set the variables `proof-mode-for-script',
`proof-mode-for-shell', etc, that actually select the right mode.
These variables are declared in `pg-vars.el'.


File: PG-adapting.info,  Node: Menus and Toolbar and User-level Commands,  Next: Proof Script Settings,  Prev: Beginning with a New Prover,  Up: Top

2 Menus, toolbar, and user-level commands
*****************************************

The variables described in this chapter configure the menus, toolbar,
and user-level commands.  They should be set in the script mode before
`proof-config-done' is called.  (Toolbar configuration must be made
before `proof-toolbar.el' is loaded, which usually is triggered
automatically by an attempt to display the toolbar).

* Menu:

* Settings for generic user-level commands::
* Menu configuration::
* Toolbar configuration::


File: PG-adapting.info,  Node: Settings for generic user-level commands,  Next: Menu configuration,  Up: Menus and Toolbar and User-level Commands

2.1 Settings for generic user-level commands
============================================

 -- Variable: proof-assistant-home-page
     Web address for information on proof assistant.
     Used for Proof General's help menu.

 -- Variable: proof-context-command
     Command to display the context in proof assistant.

 -- Variable: proof-info-command
     Command to ask for help or information in the proof assistant.
     String or fn.  If a string, the command to use.  If a function, it
     should return the command string to insert.

 -- Variable: proof-showproof-command
     Command to display proof state in proof assistant.

 -- Variable: proof-goal-command
     Command to set a goal in the proof assistant.  String or fn.
     If a string, the format character `%s' will be replaced by the
     goal string.  If a function, it should return the command string
     to insert.

 -- Variable: proof-save-command
     Command to save a proved theorem in the proof assistant.  String
     or fn.
     If a string, the format character `%s' will be replaced by the
     theorem name.  If a function, it should return the command string
     to insert.

 -- Variable: proof-find-theorems-command
     Command to search for a theorem containing a given term.  String
     or fn.
     If a string, the format character `%s' will be replaced by the
     term.  If a function, it should return the command string to send.


File: PG-adapting.info,  Node: Menu configuration,  Next: Toolbar configuration,  Prev: Settings for generic user-level commands,  Up: Menus and Toolbar and User-level Commands

2.2 Menu configuration
======================

As well as the generic Proof General menu, each proof assistant is
provided with a specific menu which can have prover-specific commands.
Proof General puts some default things on this menu, including the
commands to start/stop the prover, and the user-extensible "Favourites"
menu.

 -- Variable: PA-menu-entries
     Extra entries for proof assistant specific menu.
     A list of menu items [NAME CALLBACK ENABLER ...].  See the
     documentation of ``easy-menu-define'' for more details.

 -- Variable: PA-help-menu-entries
     Extra entries for help submenu for proof assistant specific help
     menu.
     A list of menu items [NAME CALLBACK ENABLER ...].  See the
     documentation of ``easy-menu-define'' for more details.


File: PG-adapting.info,  Node: Toolbar configuration,  Prev: Menu configuration,  Up: Menus and Toolbar and User-level Commands

2.3 Toolbar configuration
=========================

Unlike the menus, Proof General has only one toolbar.  For the "generic"
aspect of Proof General to work well, we shouldn't change (the meaning
of) the existing toolbar buttons too far.  This would discourage people
from experimenting with different proof assistants when they don't
really know them, which is one of the advantages that Proof General
brings.

But in case it is hard to map some of the generic buttons onto
functions in particular provers, and to allow extra buttons, there is a
mechanism for adjustment.

I used The Gimp to create the buttons for Proof General.  The
development distribution includes a button blank and some notes in
`etc/notes.txt' about making new buttons.

 -- Variable: proof-toolbar-entries-default
     Example value for proof-toolbar-entries.  Also used to define
     scripting menu.
     This gives a bare toolbar that works for any prover, providing the
     appropriate configuration variables are set.  To add/remove prover
     specific buttons, adjust the `<PA>-toolbar-entries' variable, and
     follow the pattern in `proof-toolbar.el' for defining functions,
     images.

 -- Variable: PA-toolbar-entries
     List of entries for Proof General toolbar and Scripting menu.
     Format of each entry is (TOKEN MENUNAME TOOLTIP TOOLBAR-P
     [VISIBLE-P]).

     For each TOKEN, we expect an icon with base filename TOKEN, a
     function proof-toolbar-<TOKEN>, and (optionally) a dynamic enabler
     proof-toolbar-<TOKEN>-enable-p.

     If VISIBLE-P is absent, or evaluates to non-nil, the item will
     appear on the toolbar or menu.  If it evaluates to nil, the item
     is not shown.

     If MENUNAME is nil, item will not appear on the scripting menu.

     If TOOLBAR-P is nil, item will not appear on the toolbar.

     The default value is ``proof-toolbar-entries-default'' which
     contains the standard Proof General buttons.

Here's an example of how to remove a button, from `af2.el':
     (setq af2-toolbar-entries
           (assq-delete-all 'state af2-toolbar-entries))


File: PG-adapting.info,  Node: Proof Script Settings,  Next: Proof Shell Settings,  Prev: Menus and Toolbar and User-level Commands,  Up: Top

3 Proof Script Settings
***********************

The variables described in this chapter should be set in the script mode
before `proof-config-done' is called.  These variables configure
recognition of commands in the proof script, and also control some of
the behaviour of script management.

* Menu:

* Recognizing commands and comments::
* Recognizing proofs::
* Recognizing other elements::
* Configuring undo behaviour::
* Nested proofs::
* Safe (state-preserving) commands::
* Activate scripting hook::
* Automatic multiple files::
* Completely asserted buffers::
* Completions::


File: PG-adapting.info,  Node: Recognizing commands and comments,  Next: Recognizing proofs,  Up: Proof Script Settings

3.1 Recognizing commands and comments
=====================================

The first four settings configure the generic parsing strategy for
commands in the proof script.  Usually only one of these three needs to
be set.  If the generic parsing functions are not flexible for your
needs, you can supply a value for `proof-script-parse-function'.

Note that for the generic functions to work properly, it is *essential*
that you set the syntax table for your mode properly, so that comments
and strings are recognized.  See the Emacs documentation to discover
how to do this (particularly for the function `modify-syntax-entry',
(*note (Elisp)Syntax Tables::).

*Note Proof script mode::, for more details of the parsing functions.

 -- Variable: proof-terminal-string
     String that terminates commands sent to prover; nil if none.

     To configure command recognition properly, you must set at least
     one of these: ``proof-script-sexp-commands'',
     ``proof-script-command-end-regexp'',
     ``proof-script-command-start-regexp'', ``proof-terminal-string'',
     or ``proof-script-parse-function''.

 -- Variable: proof-electric-terminator-noterminator
     If non-nil, electric terminator does not actually insert a
     terminator.

 -- Variable: proof-script-sexp-commands
     Non-nil if script has LISP-like syntax: commands are `top-level'
     sexps.
     You should set this variable in script mode configuration.

     To configure command recognition properly, you must set at least
     one of these: ``proof-script-sexp-commands'',
     ``proof-script-command-end-regexp'',
     ``proof-script-command-start-regexp'', ``proof-terminal-string'',
     or ``proof-script-parse-function''.

 -- Variable: proof-script-command-start-regexp
     Regular expression which matches start of commands in proof script.
     You should set this variable in script mode configuration.

     To configure command recognition properly, you must set at least
     one of these: ``proof-script-sexp-commands'',
     ``proof-script-command-end-regexp'',
     ``proof-script-command-start-regexp'', ``proof-terminal-string'',
     or ``proof-script-parse-function''.

 -- Variable: proof-script-command-end-regexp
     Regular expression which matches end of commands in proof script.
     You should set this variable in script mode configuration.

     The end of the command is considered to be the end of the match of
     this regexp.  The regexp may include a nested group, which can be
     used to recognize the start of the following command (or white
     space).  If there is a nested group, the end of the command is
     considered to be the start of the nested group, i.e.
     (`match-beginning' 1), rather than (`match-end' 0).

     To configure command recognition properly, you must set at least
     one of these: ``proof-script-sexp-commands'',
     ``proof-script-command-end-regexp'',
     ``proof-script-command-start-regexp'', ``proof-terminal-string'',
     or ``proof-script-parse-function''.

The next four settings configure the comment syntax.  Notice that to get
reliable behaviour of the parsing functions, you may need to modify the
syntax table for your prover's mode.  Read the Elisp manual (*note
(Elisp)Syntax Tables::) for details about that.

 -- Variable: proof-script-comment-start
     String which starts a comment in the proof assistant command
     language.
     The script buffer's ``comment-start'' is set to this string plus a
     space.  Moreover, comments are usually ignored during script
     management, and not sent to the proof process.

     You should set this variable for reliable working of Proof General,
     as well as ``proof-script-comment-end''.

 -- Variable: proof-script-comment-start-regexp
     Regexp which matches a comment start in the proof command language.

     The default value for this is set as (`regexp-quote'
     ``proof-script-comment-start'') but you can set this variable to
     something else more precise if necessary.

 -- Variable: proof-script-comment-end
     String which ends a comment in the proof assistant command
     language.
     Should be an empty string if comments are terminated by
     ``end-of-line'' The script buffer's ``comment-end'' is set to a
     space plus this string, if it is non-empty.

     See also ``proof-script-comment-start''.

     You should set this variable for reliable working of Proof General.

 -- Variable: proof-script-comment-end-regexp
     Regexp which matches a comment end in the proof command language.

     The default value for this is set as (`regexp-quote'
     ``proof-script-comment-end'') but you can set this variable to
     something else more precise if necessary.

 -- Variable: proof-case-fold-search
     Value for ``case-fold-search'' when recognizing portions of proof
     scripts.
     Also used for completion, via ``proof-script-complete''.  The
     default value is nil.  If your prover has a case *insensitive*
     input syntax, ``proof-case-fold-search'' should be set to t
     instead.  NB: This setting is not used for matching output from
     the prover.

Finally, the function `proof-looking-at-syntactic-context' is used
internally to help determine the syntactic structure of the buffer.
You can test it to check the settings above.  If necessary, you can
override this with a system-specific function.

 -- Function: proof-looking-at-syntactic-context
     Determine if current point is at beginning or within
     comment/string context.
     If so, return a symbol indicating this ('comment or `'string').
     This function invokes <PA-syntactic-context> if that is defined,
     otherwise it calls ``proof-looking-at-syntactic-context''.


File: PG-adapting.info,  Node: Recognizing proofs,  Next: Recognizing other elements,  Prev: Recognizing commands and comments,  Up: Proof Script Settings

3.2 Recognizing proofs
======================

Several settings each may be supplied for recognizing goal-like and
save-like commands.  The `-with-hole-' settings are used to make a
record of the name of the theorem proved.

The `-p' subsidiary predicates were added to allow more discriminating
behaviour for particular proof assistants.  (This is a typical example
of where the core framework needs some additional generalization, to
simplify matters, and allow for a smooth handling of nested proofs; the
present state is only part of the way there).

 -- Variable: proof-goal-command-regexp
     Matches a goal command in the proof script.
     This is used to make the default value for
     ``proof-goal-command-p'', used as an important part of script
     management to find the start of an atomic undo block.

 -- Variable: proof-goal-command-p
     A function to test: is this really a goal command span?

     This is added as a more refined addition to
     ``proof-goal-command-regexp'', to solve the problem that Coq and
     some other provers can have goals which look like definitions,
     etc.  (In the future we may generalize
     ``proof-goal-command-regexp'' instead).

 -- Variable: proof-goal-with-hole-regexp
     Regexp which matches a command used to issue and name a goal.
     The name of the theorem is built from the variable
     ``proof-goal-with-hole-result'' using the same convention as for
     ``query-replace-regexp''.  Used for setting names of goal..save
     regions and for default configuration of other modes (function
     menu, imenu).

     It's safe to leave this setting as nil.

 -- Variable: proof-goal-with-hole-result
     How to get theorem name after ``proof-goal-with-hole-regexp''
     match.
     String or Int.  If an int N use `match-string' to recover the
     value of the Nth parenthesis matched.  If it is a string use
     `replace-match'. In this case, `proof-save-with-hole-regexp'
     should match the entire command

 -- Variable: proof-save-command-regexp
     Matches a save command.

 -- Variable: proof-save-with-hole-regexp
     Regexp which matches a command to save a named theorem.
     The name of the theorem is built from the variable
     ``proof-save-with-hole-result'' using the same convention as
     ``query-replace-regexp''.  Used for setting names of goal..save
     and proof regions.

     It's safe to leave this setting as nil.

 -- Variable: proof-completed-proof-behaviour
     Indicates how Proof General treats commands beyond the end of a
     proof.
     Normally goal...save regions are "closed", i.e. made atomic for
     undo.  But once a proof has been completed, there may be a delay
     before the "save" command appears -- or it may not appear at all.
     Unless nested proofs are supported, this can spoil the
     undo-behaviour in script management since once a new goal arrives
     the old undo history may be lost in the prover.  So we allow Proof
     General to close off the goal..[save] region in more flexible ways.
     The possibilities are:
                  nil  -  nothing special; close only when a save arrives
            `'closeany'  -  close as soon as the next command arrives, save or not
           `'closegoal'  -  close when the next "goal" command arrives
              `'extend'  -  keep extending the closed region until a save or goal.
     If your proof assistant allows nested goals, it will be wrong to
     close off the portion of proof so far, so this variable should be
     set to nil.

     NB: `'extend' behaviour is not currently compatible with
     appearance of save commands, so don't use that if your prover has
     save commands.

 -- Variable: proof-really-save-command-p
     Is this really a save command?

     This is a more refined addition to ``proof-save-command-regexp''.
     It should be a function taking a span and command as argument, and
     can be used to track nested proofs.


File: PG-adapting.info,  Node: Recognizing other elements,  Next: Configuring undo behaviour,  Prev: Recognizing proofs,  Up: Proof Script Settings

3.3 Recognizing other elements
==============================

To configure Imenu (which in turn configures Speedbar), you may use the
following setting.  If this is unset, a generic setting based on
`proof-goal-with-hole-regexp' is configured.

 -- Variable: proof-script-imenu-generic-expression
     Regular expressions to help find definitions and proofs in a
     script.
     Value for ``imenu-generic-expression'', see documentation of Imenu
     and that variable for details.

 -- Variable: imenu-generic-expression
     The regex pattern to use for creating a buffer index.

     If non-nil this pattern is passed to `imenu--generic-function' to
     create a buffer index.

     The value should be an alist with elements that look like this:
           (MENU-TITLE REGEXP INDEX)
     or like this:
           (MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS...)
     with zero or more ARGUMENTS.  The former format creates a simple
     element in the index alist when it matches; the latter creates a
     special element of the form  (NAME FUNCTION POSITION-MARKER
     ARGUMENTS...)  with FUNCTION and ARGUMENTS beiong copied from
     `imenu-generic-expression'.

     MENU-TITLE is a string used as the title for the submenu or nil if
     the entries are not nested.

     REGEXP is a regexp that should match a construct in the buffer
     that is to be displayed in the menu; i.e., function or variable
     definitions, etc.  It contains a substring which is the name to
     appear in the menu.  See the info section on Regexps for more
     information.

     INDEX points to the substring in REGEXP that contains the name (of
     the function, variable or type) that is to appear in the menu.

     The variable is buffer-local.

     The variable `imenu-case-fold-search' determines whether or not the
     regexp matches are case sensitive. and `imenu-syntax-alist' can be
     used to alter the syntax table for the search.

     For example, see the value of `lisp-imenu-generic-expression' used
     by `lisp-mode' and `emacs-lisp-mode' with `imenu-syntax-alist' set
     locally to give the characters which normally have \"punctuation\"
     syntax \"word\" syntax during matching."


File: PG-adapting.info,  Node: Configuring undo behaviour,  Next: Nested proofs,  Prev: Recognizing other elements,  Up: Proof Script Settings

3.4 Configuring undo behaviour
==============================

The settings here are used to configure the way "undo" commands are
calculated.

 -- Variable: proof-non-undoables-regexp
     Regular expression matching commands which are *not* undoable.
     These are commands which should not appear in proof scripts, for
     example, undo commands themselves (if the proof assistant cannot
     "redo" an "undo").  Used in default functions
     ``proof-generic-state-preserving-p'' and
     ``proof-generic-count-undos''.  If you don't use those, may be
     left as nil.

 -- Variable: proof-undo-n-times-cmd
     Command to undo n steps of the currently open goal.
     String or function.  If this is set to a string, `%s' will be
     replaced by the number of undo steps to issue.  If this is set to
     a function, it should return a list of the appropriate commands
     (given the number of undo steps).

     This setting is used for the default ``proof-generic-count-undos''.
     If you set ``proof-count-undos-fn'' to some other function, there
     is no need to set this variable.

 -- Variable: proof-ignore-for-undo-count
     Matcher for script commands to be ignored in undo count.
     May be left as nil, in which case it will be set to
     ``proof-non-undoables-regexp''.  Used in default function
     ``proof-generic-count-undos''.

 -- Variable: proof-count-undos-fn
     Function to calculate a list of commands to undo to reach a target
     span.
     The function takes a span as an argument, and should return a
     string which is the command to undo to the target span.  The
     target is guaranteed to be within the current (open) proof.  This
     is an important function for script management.  The default
     setting ``proof-generic-count-undos'' is based on the settings
     ``proof-non-undoables-regexp'' and ``proof-non-undoables-regexp''.

 -- Function: proof-generic-count-undos span
     Count number of undos in SPAN, return commands needed to undo that
     far.
     Command is set using ``proof-undo-n-times-cmd''.

     A default value for ``proof-count-undos-fn''.

     For this function to work properly, you must configure
     ``proof-undo-n-times-cmd'' and ``proof-ignore-for-undo-count''.

 -- Variable: proof-find-and-forget-fn
     Function to return list of commands to forget to before its
     argument span.
     This setting is used to for retraction (undoing) in proof scripts.

     It should undo the effect of all settings between its target span
     up to (`proof-unprocessed-begin').  This may involve forgetting a
     number of definitions, declarations, or whatever.

     If return value is nil, it means there is nothing to do.

     This is an important function for script management.  Study one of
     the existing instantiations for examples of how to write it, or
     leave it set to the default function
     ``proof-generic-find-and-forget'' (which see).

 -- Function: proof-generic-find-and-forget span
     Calculate a forget/undo command to forget back to SPAN.
     This is a long-range forget: we know that there is no open goal at
     the moment, so forgetting involves unbinding declarations, etc,
     rather than undoing proof steps.

     This generic implementation assumes it is enough to find the
     nearest following span with a `name' property, and retract that
     using ``proof-forget-id-command'' with the given name.

     If this behaviour is not correct, you must customize the function
     with something different.

 -- Variable: proof-forget-id-command
     Command to forget back to a given named span.
     A string; `%s' will be replaced by the name of the span.

     This is only used in the implementation of
     ``proof-generic-find-and-forget'', you only need to set if you use
     that function (by not customizing ``proof-find-and-forget-fn''.

 -- Variable: pg-topterm-goalhyplit-fn
     Function to return cons if point is at a goal/hypothesis/literal.
     This is used to parse the proofstate output to mark it up for
     proof-by-pointing or literal command insertion.  It should return
     a cons or nil.  First element of the cons is a symbol, `'goal'',
     `'hyp'' or `'lit''.  The second element is a string: the goal,
     hypothesis, or literal command itself.

     If you leave this variable unset, no proof-by-pointing markup will
     be attempted.

 -- Variable: proof-kill-goal-command
     Command to kill the currently open goal.

     If this is set to nil, PG will expect ``proof-find-and-forget-fn''
     to do all the work of retracting to an arbitrary point in a file.
     Otherwise, the generic split-phase mechanism will be used:

     1. If inside an unclosed proof, use `proof-count-undos'.  2. If
     retracting to before an unclosed proof, use
     ``proof-kill-goal-command'', followed by
     ``proof-find-and-forget-fn'' if necessary.


File: PG-adapting.info,  Node: Nested proofs,  Next: Safe (state-preserving) commands,  Prev: Configuring undo behaviour,  Up: Proof Script Settings

3.5 Nested proofs
=================

Proof General allows configuration for provers which have particular
notions of nested proofs.  The right thing may happen automatically, or
you may need to adjust some of the following settings.

First, you should alter the next setting if the prover retains history
for nested proofs.

 -- Variable: proof-nested-goals-history-p
     Whether the prover supports recovery of history for nested proofs.
     If it does (non-nil), Proof General will retain history inside
     nested proofs.  If it does not, Proof General will amalgamate
     nested proofs into single steps within the outer proof.
Second, it may happen (i.e. it does for Coq) that the prover has a
history mechanism which necessitates keeping track of the number of
nested "undoable" commands, even if the history of the proof itself is
lost.

 -- Variable: proof-nested-undo-regexp
     Regexp for commands that must be counted in nested goal-save
     regions.

     Used for provers which allow nested atomic goal-saves, but with
     some nested history that must be undone specially.

     At the moment, the behaviour is that a goal-save span has a
     `'nestedundos' property which is set to the number of commands
     within it which match this regexp.  The idea is that the
     prover-specific code can create a customized undo command to
     retract the goal-save region, based on the `'nestedundos' setting.
     Coq uses this to forget declarations, since declarations in Coq
     reside in a separate context with its own (flat) history.


File: PG-adapting.info,  Node: Safe (state-preserving) commands,  Next: Activate scripting hook,  Prev: Nested proofs,  Up: Proof Script Settings

3.6 Safe (state-preserving) commands
====================================

A proof command is "safe" if it can be issued away from the proof
script.  For this to work it should be state-preserving in the proof
assistant (with respect to an on-going proof).

 -- Variable: proof-state-preserving-p
     A predicate, non-nil if its argument (a command) preserves the
     proof state.
     This is a safety-test used by ``proof-minibuffer-cmd'' to filter
     out scripting commands which should be entered directly into the
     script itself.

     The default setting for this function,
     ``proof-generic-state-preserving-p'' tests by negating the match
     on ``proof-non-undoables-regexp''.

 -- Function: proof-generic-state-preserving-p cmd
     Is CMD state preserving?  Match on ``proof-non-undoables-regexp''.


File: PG-adapting.info,  Node: Activate scripting hook,  Next: Automatic multiple files,  Prev: Safe (state-preserving) commands,  Up: Proof Script Settings

3.7 Activate scripting hook
===========================

 -- Variable: proof-activate-scripting-hook
     Hook run when a buffer is switched into scripting mode.
     The current buffer will be the newly active scripting buffer.

     This hook may be useful for synchronizing with the proof
     assistant, for example, to switch to a new theory (in case that
     isn't already done by commands in the proof script).

     When functions in this hook are called, the variable
     `activated-interactively' will be non-nil if
     ``proof-activate-scripting'' was called interactively (rather than
     as a side-effect of some other action).  If a hook function sends
     commands to the proof process, it should wait for them to complete
     (so the queue is cleared for scripting commands), unless
     activated-interactively is set.


File: PG-adapting.info,  Node: Automatic multiple files,  Next: Completely asserted buffers,  Prev: Activate scripting hook,  Up: Proof Script Settings

3.8 Automatic multiple files
============================

*Note Handling Multiple Files::, for more details about this setting.

 -- Variable: proof-auto-multiple-files
     Whether to use automatic multiple file management.
     If non-nil, Proof General will automatically retract a script file
     whenever another one is retracted which it depends on.  It assumes
     a simple linear dependency between files in the order which they
     were processed.

     If your proof assistant has no management of file dependencies, or
     one which depends on a simple linear context, you may be able to
     use this setting to good effect.  If the proof assistant has more
     complex file dependencies then you should configure it to
     communicate with Proof General about the dependencies rather than
     using this setting.


File: PG-adapting.info,  Node: Completely asserted buffers,  Next: Completions,  Prev: Automatic multiple files,  Up: Proof Script Settings

3.9 Completely asserted buffers
===============================

When switching scripting from buffer A to buffer B Proof General
normally offers the choice of either completely retracting or
completely asserting buffer A. The option to completely assert buffer A
is offered, because the material in B may depend on A.  Even if B does
not depend on A, it does no harm if one keeps the development of A
loaded in the proof assistant. This observation is true for many proof
assistants.

One exception is Coq. Assume file B depends on file A. When Coq
processes B it does not read the sources of A. Instead it loads a
compiled object representation of A. Therefore, when switching from A
to B, it does make no sense to keep the material of A loaded in the
proof assistant. For Coq, the material of A may even provoke errors on
correct input. Therefore, for coq, the right behaviour is to completely
retract buffer A before switching to B.

 -- Variable: proof-no-fully-processed-buffer
     Set to t if buffers should always retract before scripting
     elsewhere.
     Leave at nil if fully processed buffers make sense for the current
     proof assistant. If nil the user can choose to fully assert a
     buffer when starting scripting in a different buffer. If t there
     is only the choice to fully retract the active buffer before
     starting scripting in a different buffer. This last behavior is
     needed for Coq.


File: PG-adapting.info,  Node: Completions,  Prev: Completely asserted buffers,  Up: Proof Script Settings

3.10 Completions
================

Proof General allows provers to create a completion table to help
writing keywords and identifiers in proof scripts.  This is documented
in the main Proof General user manual but summarized here for (a
different kind of) completion.

Completions are filled in according to what has been recently typed,
from a database of symbols.  The database is automatically saved at the
end of a session.  Completion is usually a hand-wavy thing, so we don't
make any attempt to maintain a precise completion table or anything.

The completion table maintained by `complete.el' is initialized from
`PA-completion-table' when `proof-script.el' is loaded.  This is done
with the function `proof-add-completions' which you may want to call at
other times.

 -- Variable: PA-completion-table
     List of identifiers to use for completion for this proof assistant.
     Completion is activated with M-x complete.

     If this table is empty or needs adjusting, please make changes
     using ``customize-variable'' and post suggestions at
     http://proofgeneral.inf.ed.ac.uk/trac

 -- Command: proof-add-completions
     Add completions from <PA>-completion-table to completion database.
     Uses ``add-completion'' with a negative number of uses and ancient
     last use time, to discourage saving these into the users database.


File: PG-adapting.info,  Node: Proof Shell Settings,  Next: Goals Buffer Settings,  Prev: Proof Script Settings,  Up: Top

4 Proof Shell Settings
**********************

The variables in this chapter concern the proof shell mode, and are the
largest group.  They are split into several subgroups.  The first
subgroup are commands invoked at various points.  The second subgroup of
variables are concerned with matching the output from the proof
assistant.  The final subgroup contains various hooks which you can set
to add lisp customization to Proof General in various points (some of
them are also used internally for behaviour you may wish to adjust).

Variables for configuring the proof shell are put into the customize
group `proof-shell'.

These should be set in the shell mode configuration, before
`proof-shell-config-done' is called.

To understand the way the proof assistant runs inside Emacs, you may
want to refer to the `comint.el' (Command interpreter) package
distributed with Emacs.  This package controls several shell-like modes
available in Emacs, including the `proof-shell-mode' and all specific
shell modes derived from it.

* Menu:

* Proof shell commands::
* Script input to the shell::
* Settings for matching various output from proof process::
* Settings for matching urgent messages from proof process::
* Hooks and other settings::


File: PG-adapting.info,  Node: Proof shell commands,  Next: Script input to the shell,  Up: Proof Shell Settings

4.1 Commands
============

Settings in this section configure Proof General with commands to send
to the prover to activate certain actions.

 -- Variable: proof-prog-name
     System command to run the proof assistant in the proof shell.
     May contain arguments separated by spaces, but see also the prover
     specific settings `<PA>-prog-args' and `<PA>-prog-env'.

     Remark: if `<PA>-prog-args' is non-nil, then ``proof-prog-name''
     is considered strictly: it must contain *only* the program name
     with no option, spaces are interpreted literally as part of the
     program name.

 -- Variable: PA-prog-args
     Arguments to be passed to ``proof-prog-name'' to run the proof
     assistant.
     If non-nil, will be treated as a list of arguments for
     ``proof-prog-name''.  Otherwise ``proof-prog-name'' will be split
     on spaces to form arguments.

     Remark: Arguments are interpreted strictly: each one must contain
     only one word, with no space (unless it is the same word). For
     example if the arguments are -x foo -y bar, then the list should
     be '("-x" "foo" "-y" "bar"), notice that '("-x foo" "-y bar") is
     *wrong*.

 -- Variable: PA-prog-env
     Modifications to ``process-environment'' made before running
     ``proof-prog-name''.
     Each element should be a string of the form ENVVARNAME=VALUE.
     They will be added to the environment before launching the prover
     (but not pervasively).  For example for coq on Windows you might
     need something like: (setq `coq-prog-env' '("HOME=C:\Program
     Files\Coq\"))

 -- Variable: proof-shell-auto-terminate-commands
     Non-nil if Proof General should try to add terminator to every
     command.
     If non-nil, whenever a command is sent to the prover using
     ``proof-shell-invisible-command'', Proof General will check to see
     if it ends with ``proof-terminal-string'', and add it if not.  If
     ``proof-terminal-string'' is nil, this has no effect.

 -- Variable: proof-shell-pre-sync-init-cmd
     The command for configuring the proof process to gain
     synchronization.
     This command is sent before Proof General's synchronization
     mechanism is engaged, to allow customization inside the process to
     help gain syncrhonization (e.g. engaging special markup).

     It is better to configure the proof assistant for this purpose via
     command line options if possible, in which case this variable does
     not need to be set.

     See also ``proof-shell-init-cmd''.

 -- Variable: proof-shell-init-cmd
     The command(s) for initially configuring the proof process.
     This command is sent to the process as soon as synchronization is
     gained (when an annotated prompt is first recognized).  It can be
     used to configure the proof assistant in some way, or print a
     welcome message (since output before the first prompt is
     discarded).

     See also ``proof-shell-pre-sync-init-cmd''.

 -- Variable: proof-shell-restart-cmd
     A command for re-initialising the proof process.

 -- Variable: proof-shell-quit-cmd
     A command to quit the proof process.  If nil, send EOF instead.

 -- Variable: proof-shell-cd-cmd
     Command to the proof assistant to change the working directory.
     The format character `%s' is replaced with the directory, and the
     escape sequences in ``proof-shell-filename-escapes'' are applied
     to the filename.

     This setting is used to define the function ``proof-cd'' which
     changes to the value of (`default-directory') for script buffers.
     For files, the value of (`default-directory') is simply the
     directory the file resides in.

     NB: By default, ``proof-cd'' is called from
     ``proof-activate-scripting-hook'', so that the prover switches to
     the directory of a proof script every time scripting begins.

 -- Variable: proof-shell-start-silent-cmd
     Command to turn prover goals output off when sending many script
     commands.
     If non-nil, Proof General will automatically issue this command to
     help speed up processing of long proof scripts.  See also
     ``proof-shell-stop-silent-cmd''.  NB: terminator not added to
     command.

 -- Variable: proof-shell-stop-silent-cmd
     Command to turn prover output on.
     If non-nil, Proof General will automatically issue this command to
     help speed up processing of long proof scripts.  See also
     ``proof-shell-start-silent-cmd''.  NB: Terminator not added to
     command.

 -- Variable: proof-shell-silent-threshold
     Number of waiting commands in the proof queue needed to trigger
     silent mode.
     Default is 2, but you can raise this in case switching silent mode
     on or off is particularly expensive (or make it ridiculously large
     to disable silent mode altogether).
*Note Handling Multiple Files::, for more details about the final two
settings in this group,

 -- Variable: proof-shell-inform-file-processed-cmd
     Command to the proof assistant to tell it that a file has been
     processed.
     The format character `%s' is replaced by a complete filename for a
     script file which has been fully processed interactively with
     Proof General.  See ``proof-format-filename'' for other
     possibilities to process the filename.

     This setting used to interface with the proof assistant's internal
     management of multiple files, so the proof assistant is kept aware
     of which files have been processed.  Specifically, when scripting
     is deactivated in a completed buffer, it is added to Proof
     General's list of processed files, and the prover is told about it
     by issuing this command.

     If this is set to nil, no command is issued.

     See also: ``proof-shell-inform-file-retracted-cmd'',
     ``proof-shell-process-file'',
     ``proof-shell-compute-new-files-list''.

 -- Variable: proof-shell-inform-file-retracted-cmd
     Command to the proof assistant to tell it that a file has been
     retracted.
     The format character `%s' is replaced by a complete filename for a
     script file which Proof General wants the prover to consider as not
     completely processed.  See ``proof-format-filename'' for other
     possibilities to process the filename.

     This is used to interface with the proof assistant's internal
     management of multiple files, so the proof assistant is kept aware
     of which files have been processed.  Specifically, when scripting
     is activated, the file is removed from Proof General's list of
     processed files, and the prover is told about it by issuing this
     command.  The action may cause the prover in turn to suggest to
     Proof General that files depending on this one are also unlocked.

     If this is set to nil, no command is issued.

     It is also possible to set this value to a function which will be
     invoked on the name of the retracted file, and should remove the
     ancestor files from ``proof-included-files-list'' by some other
     calculation.

     See also: ``proof-shell-inform-file-processed-cmd'',
     ``proof-shell-process-file'',
     ``proof-shell-compute-new-files-list''.


File: PG-adapting.info,  Node: Script input to the shell,  Next: Settings for matching various output from proof process,  Prev: Proof shell commands,  Up: Proof Shell Settings

4.2 Script input to the shell
=============================

Generally, commands from the proof script are sent verbatim to the proof
process running in the proof shell.  For historical reasons, carriage
returns are stripped by default.  You can set
`proof-shell-strip-crs-from-input' to adjust that.  For more
sophisticated pre-processing of the sent string, you may like to set
`proof-shell-insert-hook'.

 -- Variable: proof-shell-strip-crs-from-input
     If non-nil, replace carriage returns in every input with spaces.
     This is enabled by default: it is appropriate for many systems
     based on human input, because several CR's can result in several
     prompts, which may mess up the display (or even worse, the
     synchronization).

     If the prover can be set to output only one prompt for every chunk
     of input, then newlines can be retained in the input.

 -- Variable: proof-shell-insert-hook
     Hooks run by ``proof-shell-insert'' before inserting a command.
     Can be used to configure the proof assistant to the interface in
     various ways - for example, to observe or alter the commands sent
     to the prover, or to sneak in extra commands to configure the
     prover.

     This hook is called inside a ``save-excursion'' with the
     ``proof-shell-buffer'' current, just before inserting and sending
     the text in the variable `string'.  The hook can massage `string'
     or insert additional text directly into the ``proof-shell-buffer''.
     Before sending `string', it will be stripped of carriage returns.

     Additionally, the hook can examine the variable `action'.  It will
     be a symbol, set to the callback command which is executed in the
     proof shell filter once `string' has been processed.  The `action'
     variable suggests what class of command is about to be inserted,
     the first two are normally the ones of interest:
           `'proof-done-advancing'       A "forward" scripting command
           `'proof-done-retracting'      A "backward" scripting command
           `'proof-done-invisible'       A non-scripting command
           `'proof-shell-set-silent'     Indicates prover output has been surpressed
           `'proof-shell-clear-silent'   Indicates prover output has been restored
           `'init-cmd'                   Early initialization command sent to prover
     Caveats: You should be very careful about setting this hook.  Proof
     General relies on a careful synchronization with the process
     between inputs and outputs.  It expects to see a prompt for each
     input it sends from the queue.  If you add extra input here and it
     causes more prompts than expected, things will break!  Extending
     the variable `string' may be safer than inserting text directly,
     since it is stripped of carriage returns before being sent.

     Example uses: LEGO uses this hook for setting the pretty printer
     width if the window width has changed; Plastic uses it to remove
     literate-style markup from `string'.

     See also ``proof-script-preprocess'' which can munge text when it
     is added to the queue of commands.


File: PG-adapting.info,  Node: Settings for matching various output from proof process,  Next: Settings for matching urgent messages from proof process,  Prev: Script input to the shell,  Up: Proof Shell Settings

4.3 Settings for matching various output from proof process
===========================================================

These settings control the way Proof General reacts to process output.
The single most important setting is
`proof-shell-annotated-prompt-regexp', which must be set as part of the
prover configuraton.  This is used to configure the communication with
the prover process.

 -- Variable: pg-subterm-first-special-char
     First special character.
     Codes above this character can have special meaning to Proof
     General, and are stripped from the prover's output strings.  Leave
     unset if no special characters are being used.

 -- Variable: proof-shell-annotated-prompt-regexp
     Regexp matching a (possibly annotated) prompt pattern.

     THIS IS THE MOST IMPORTANT SETTING TO CONFIGURE!!

     Output is grabbed between pairs of lines matching this regexp, and
     the appearance of this regexp is used by Proof General to
     recognize when the prover has finished processing a command.

     To help speed up matching you may be able to annotate the proof
     assistant prompt with a special character not appearing in
     ordinary output, which should appear in this regexp.

 -- Variable: proof-shell-error-regexp
     Regexp matching an error report from the proof assistant.

     We assume that an error message corresponds to a failure in the
     last proof command executed.  So don't match mere warning messages
     with this regexp.  Moreover, an error message should *not* be
     matched as an eager annotation (see
     ``proof-shell-eager-annotation-start'') otherwise it will be lost.

     Error messages are considered to begin from
     ``proof-shell-error-regexp'' and continue until the next prompt.
     The variable ``proof-shell-truncate-before-error'' controls
     whether text before the error message is displayed.

     The engine matches interrupts before errors, see
     ``proof-shell-interrupt-regexp''.

     It is safe to leave this variable unset (as nil).

 -- Variable: proof-shell-interrupt-regexp
     Regexp matching output indicating the assistant was interrupted.
     We assume that an interrupt message corresponds to a failure in
     the last proof command executed.  So don't match mere warning
     messages with this regexp.  Moreover, an interrupt message should
     not be matched as an eager annotation (see
     ``proof-shell-eager-annotation-start'') otherwise it will be lost.

     The engine matches interrupts before errors, see
     ``proof-shell-error-regexp''.

     It is safe to leave this variable unset (as nil).

 -- Variable: proof-shell-truncate-before-error
     Non-nil means truncate output that appears before error messages.
     If nil, the whole output that the prover generated before the last
     error message will be shown.

     NB: the default setting for this is t to be compatible with
     behaviour in Proof General before version 3.4.  The more obvious
     setting for new instances is probably nil.

     Interrupt messages are treated in the same way.  See
     ``proof-shell-error-regexp'' and ``proof-shell-interrupt-regexp''.

 -- Variable: proof-shell-proof-completed-regexp
     Regexp matching output indicating a finished proof.

     When output which matches this regexp is seen, we clear the goals
     buffer in case this is not also marked up as a `goals' type of
     message.

     We also enable the QED function (save a proof) and we may
     automatically close off the proof region if another goal appears
     before a save command, depending on whether the prover supports
     nested proofs or not.

 -- Variable: proof-shell-start-goals-regexp
     Regexp matching the start of the proof state output.
     This is an important setting.  Output between
     ``proof-shell-start-goals-regexp'' and
     ``proof-shell-end-goals-regexp'' will be pasted into the goals
     buffer and possibly analysed further for proof-by-pointing markup.
     If it is left as nil, the goals buffer will not be used.

     The goals display starts at the beginning of the match on this
     regexp, unless it has a match group, in which case it starts at
     (`match-end' 1).

 -- Variable: proof-shell-end-goals-regexp
     Regexp matching the end of the proof state output, or nil.
     This allows a shorter form of the proof state output to be
     displayed, in case several messages are combined in a command
     output.

     The portion treated as the goals output will be that between the
     match on ``proof-shell-start-goals-regexp'' (which see) and the
     start of the match on ``proof-shell-end-goals-regexp''.

     If nil, use the whole of the output from the match on
     ``proof-shell-start-goals-regexp'' up to the next prompt.

 -- Variable: proof-shell-assumption-regexp
     A regular expression matching the name of assumptions.

     At the moment, this setting is not used in the generic Proof
     General.

     Future use may provide a generic implementation for
     ``pg-topterm-goalhyplit-fn'', used to help parse the goals buffer
     to annotate it for proof by pointing.


File: PG-adapting.info,  Node: Settings for matching urgent messages from proof process,  Next: Hooks and other settings,  Prev: Settings for matching various output from proof process,  Up: Proof Shell Settings

4.4 Settings for matching urgent messages from proof process
============================================================

Among the various dialogue messages that the proof assistant outputs
during proof, Proof General can consider certain messages to be
"urgent".  When processing many lines of a proof, Proof General will
normally supress the output, waiting until the final message appears
before displaying anything to the user.  Urgent messages escape this:
typically they include messages that the prover wants the user to
notice, for example, perhaps, file loading messages, timing statistics
or dedicated tracing messages which can be sent to the `*trace*' buffer.

So that Proof General notices, these urgent messages should be marked-up
with "eager" annotations.

 -- Variable: proof-shell-eager-annotation-start
     Eager annotation field start.  A regular expression or nil.
     An "eager annotation indicates" to Proof General that some
     following output should be displayed (or processed) immediately
     and not accumulated for parsing later.  Note that this affects
     processing of output which is ordinarily accumulated: output which
     appears before the eager annotation start will be discarded.

     The start/end annotations can be used to hilight the output, but
     are stripped from display of the message in the minibuffer.

     It is useful to recognize (starts of) warnings or file-reading
     messages with this regexp.  You must also recognize any special
     messages from the prover to PG with this regexp (e.g.
     ``proof-shell-clear-goals-regexp'',
     ``proof-shell-retract-files-regexp'', etc.)

     See also ``proof-shell-eager-annotation-start-length'',
     ``proof-shell-eager-annotation-end''.

     Set to nil to disable this feature.

 -- Variable: proof-shell-eager-annotation-start-length
     Maximum length of an eager annotation start.
     Must be set to the maximum length of the text that may match
     ``proof-shell-eager-annotation-start'' (at least 1).  If this
     value is too low, eager annotations may be lost!

     This value is used internally by Proof General to optimize the
     process filter to avoid unnecessary searching.

 -- Variable: proof-shell-eager-annotation-end
     Eager annotation field end.  A regular expression or nil.
     An eager annotation indicates to Emacs that some following output
     should be displayed or processed immediately.

     See also ``proof-shell-eager-annotation-start''.

     It is nice to recognize (ends of) warnings or file-reading messages
     with this regexp.  You must also recognize (ends of) any special
     messages from the prover to PG with this regexp (e.g.
     ``proof-shell-clear-goals-regexp'',
     ``proof-shell-retract-files-regexp'', etc.)

     The default value is "\n" to match up to the end of the line.

The default action for urgent messages is to display them in the
response buffer, highlighted.  But we also allow for some control
messages, issued from the proof assistant to Proof General and not
intended for the user to see.  These are recognized in the same way as
urgent messages (marked with eager annotations), so they will be acted
on as soon as they are issued by the prover.

 -- Variable: proof-shell-clear-response-regexp
     Regexp matching output telling Proof General to clear the response
     buffer.

     More precisely, this should match a string which is bounded by
     matches on ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

     This feature is useful to give the prover more control over what
     output is shown to the user.  Set to nil to disable.

 -- Variable: proof-shell-clear-goals-regexp
     Regexp matching output telling Proof General to clear the goals
     buffer.

     More precisely, this should match a string which is bounded by
     matches on ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

     This feature is useful to give the prover more control over what
     output is shown to the user.  Set to nil to disable.

 -- Variable: proof-shell-interactive-prompt-regexp
     Matches output from the prover which indicates an interactive
     prompt.
     If we match this, we suppose that the prover has switched to an
     interactive diagnostic mode which requires direct interaction with
     the shell rather than via script management.  In this case, the
     shell buffer will be displayed and the user left to their own
     devices.

     Note: this should match a string which is bounded by matches on
     ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

 -- Variable: proof-shell-trace-output-regexp
     Matches tracing output which should be displayed in trace buffer.
     Each line which matches this regexp but would otherwise be treated
     as an ordinary response, is sent to the trace buffer instead of the
     response buffer.

     This is intended for unusual debugging output from the prover,
     rather than ordinary output from final proofs.

     This should match a string which is bounded by matches on
     ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

     Set to nil to disable.

 -- Variable: proof-shell-set-elisp-variable-regexp
     Matches output telling Proof General to set some variable.
     This allows the proof assistant to configure Proof General directly
     and dynamically.   (It's also a fantastic backdoor security risk).

     More precisely, this should match a string which is bounded by
     matches on ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

     If the regexp matches output from the proof assistant, there
     should be two match strings: (`match-string' 1) should be the name
     of the elisp variable to be set, and (`match-string' 2) should be
     the value of the variable (which will be evaluated as a Lisp
     expression).

     A good markup for the second string is to delimit with #'s, since
     these are not valid syntax for elisp evaluation.

     Elisp errors will be trapped when evaluating; set
     ``proof-general-debug'' to be informed when this happens.

     Example uses are to adjust PG's internal copies of proof
     assistant's settings, or to make automatic dynamic syntax
     adjustments in Emacs to match changes in theory, etc.

     If you pick a dummy variable name (e.g. `proof-dummy-setting') you
     can just evaluation arbitrary elisp expressions for their side
     effects, to adjust menu entries, or even launch auxiliary programs.
     But use with care - there is no protection against catastrophic
     elisp!

     This setting could also be used to move some configuration settings
     from PG to the prover, but this is not really supported (most
     settings must be made before this mechanism will work).  In
     future, the PG standard protocol, PGIP, will use this mechanism
     for making all settings.

 -- Variable: proof-shell-theorem-dependency-list-regexp
     Matches output telling Proof General about dependencies.
     This is to allow navigation and display of dependency information.
     The output from the prover should be a message with the form
             DEPENDENCIES OF  X Y Z   ARE  A B C
     with X Y Z, A B C separated by whitespace or somehow else (see
     ``proof-shell-theorem-dependency-list-split''.  This variable
     should be set to a regexp to match the overall message (which
     should be an urgent message), with two sub-matches for X Y Z and A
     B C.

     This is an experimental feature, currently work-in-progress.

Two important control messages are recognized by
`proof-shell-process-file' and `proof-shell-retract-files-regexp', used
for synchronizing Proof General with a file loading mechanism built
into the proof assistant.  *Note Handling Multiple Files::, for more
details about how to use the final four settings described here.

 -- Variable: proof-shell-process-file
     A pair (REGEXP . FUNCTION) to match a processed file name.

     If REGEXP matches output, then the function FUNCTION is invoked.
     It must return the name of a script file (with complete path) that
     the system has successfully processed.  In practice, FUNCTION is
     likely to inspect the match data.  If it returns the empty string,
     the file name of the scripting buffer is used instead.  If it
     returns nil, no action is taken.

     More precisely, REGEXP should match a string which is bounded by
     matches on ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

     Care has to be taken in case the prover only reports on compiled
     versions of files it is processing.  In this case, FUNCTION needs
     to reconstruct the corresponding script file name.  The new (true)
     file name is added to the front of ``proof-included-files-list''.

 -- Variable: proof-shell-retract-files-regexp
     Matches a message that the prover has retracted a file.

     More precisely, this should match a string which is bounded by
     matches on ``proof-shell-eager-annotation-start'' and
     ``proof-shell-eager-annotation-end''.

     At this stage, Proof General's view of the processed files is out
     of date and needs to be updated with the help of the function
     ``proof-shell-compute-new-files-list''.

 -- Variable: proof-shell-compute-new-files-list
     Function to update `proof-included-files list'.

     It needs to return an up-to-date list of all processed files.  The
     result will be stored in ``proof-included-files-list''.

     This function is called when ``proof-shell-retract-files-regexp''
     has been matched in the prover output.

     In practice, this function is likely to inspect the previous
     (global) variable ``proof-included-files-list'' and the match data
     triggered by ``proof-shell-retract-files-regexp''.

 -- Variable: proof-cannot-reopen-processed-files
     Non-nil if the prover allows re-opening of already processed files.

     If the user has used Proof General to process a file incrementally,
     then PG will retain the spans recording undo history in the buffer
     corresponding to that file (provided it remains visited in Emacs).

     If the prover allows, it will be possible to undo to a position
     within this file.  If the prover does *not* allow this, this
     variable should be set non-nil, so that when a completed file is
     activated for scripting (to do undo operations), the whole history
     is discarded.


File: PG-adapting.info,  Node: Hooks and other settings,  Prev: Settings for matching urgent messages from proof process,  Up: Proof Shell Settings

4.5 Hooks and other settings
============================

 -- Variable: proof-shell-filename-escapes
     A list of escapes that are applied to %s for filenames.
     A list of cons cells, car of which is string to be replaced by the
     cdr.  For example, when directories are sent to Isabelle, HOL, and
     Coq, they appear inside ML strings and the backslash character and
     quote characters must be escaped.  The setting
            '(("\\\\" . "\\\\")
              ("\"" . "\\\""))
     achieves this.   This does not apply to LEGO, which does not need
     backslash escapes and does not allow filenames with quote
     characters.

     This setting is used inside the function ``proof-format-filename''.

 -- Variable: proof-shell-process-connection-type
     The value of ``process-connection-type'' for the proof shell.
     Set non-nil for ptys, nil for pipes.

 -- Variable: proof-shell-handle-error-or-interrupt-hook
     Run after an error or interrupt has been reported in the response
     buffer.
     Hook functions may inspect ``proof-shell-last-output-kind'' to
     determine whether the cause was an error or interrupt.  Possible
     values for this hook include:
           ``proof-goto-end-of-locked-on-error-if-pos-not-visible-in-window''
           ``proof-goto-end-of-locked-if-pos-not-visible-in-window''
     which move the cursor in the scripting buffer on an error or
     error/interrupt.

     Remark: This hook is called from shell buffer.  If you want to do
     something in scripting buffer, ``save-excursion'' and/or
     ``set-buffer''.

 -- Variable: proof-shell-pre-interrupt-hook
     Run immediately after ``comint-interrupt-subjob'' is called.
     This hook is added to allow customization for systems that query
     the user before returning to the top level.

 -- Variable: proof-shell-handle-output-system-specific
     Set this variable to handle system specific output.
     Errors and interrupts are recognised in the function
     ``proof-shell-handle-immediate-output''.  Later output is handled
     by ``proof-shell-handle-delayed-output'', which displays messages
     to the user in *goals* and *response* buffers.

     This hook can run between the two stages to take some effect.

     It should be a function which is passed (cmd string) as arguments,
     where `cmd' is a string containing the currently processed command
     and `string' is the response from the proof system.  If action is
     taken and goals/response display should be prevented, the function
     should update the variable ``proof-shell-last-output-kind'' to
     some non-nil symbol.

     The symbol will be compared against standard ones, see
     documentation of ``proof-shell-last-output-kind''.  A suggested
     canonical non-standard symbol is `'systemspecific'.


File: PG-adapting.info,  Node: Goals Buffer Settings,  Next: Splash Screen Settings,  Prev: Proof Shell Settings,  Up: Top

5 Goals Buffer Settings
***********************

The goals buffer settings allow configuration of Proof General for proof
by pointing or similar features.  See the Proof General documentation
web page (http://proofgeneral.inf.ed.ac.uk/doc) for a link to the
technical report ECS-LFCS-97-368 which hints at how to use these
settings.

 -- Variable: pg-goals-change-goal
     Command to change to the goal `%s'.

 -- Variable: pbp-goal-command
     Command sent when `pg-goals-button-action' is requested on a goal.

 -- Variable: pbp-hyp-command
     Command sent when `pg-goals-button-action' is requested on an
     assumption.

 -- Variable: pg-goals-error-regexp
     Regexp indicating that the proof process has identified an error.

 -- Variable: proof-shell-result-start
     Regexp matching start of an output from the prover after pbp
     commands.
     In particular, after a ``pbp-goal-command'' or a
     ``pbp-hyp-command''.

 -- Variable: proof-shell-result-end
     Regexp matching end of output from the prover after pbp commands.
     In particular, after a ``pbp-goal-command'' or a
     ``pbp-hyp-command''.

 -- Variable: pg-subterm-start-char
     Opening special character for subterm markup.
     Subsequent special characters with values *below*
     ``pg-subterm-first-special-char'' are assumed to be subterm
     position indicators.  Annotations should be finished with
     ``pg-subterm-sep-char''; the end of the concrete syntax is
     indicated by ``pg-subterm-end-char''.

     If ``pg-subterm-start-char'' is nil, subterm markup is disabled.

 -- Variable: pg-subterm-sep-char
     Finishing special for a subterm markup.
     See doc of ``pg-subterm-start-char''.

 -- Variable: pg-topterm-regexp
     Annotation regexp that indicates the beginning of a "top" element.
     A "top" element may be a sub-goal to be proved or a named
     hypothesis, for example.  It could also be a literal command to
     insert and send back to the prover.

     The function ``pg-topterm-goalhyplit-fn'' examines text following
     this special character, to determine what kind of top element it
     is.

     This setting is also used to see if proof-by-pointing features are
     configured.  If it is unset, some of the code for parsing the
     prover output is disabled.

 -- Variable: pg-subterm-end-char
     Closing special character for subterm markup.
     See ``pg-subterm-start-char''.


File: PG-adapting.info,  Node: Splash Screen Settings,  Next: Global Constants,  Prev: Goals Buffer Settings,  Up: Top

6 Splash Screen Settings
************************

The splash screen can be configured, in a rather limited way.

 -- Variable: proof-splash-time
     Minimum number of seconds to display splash screen for.
     The splash screen may be displayed for a wee while longer than
     this, depending on how long it takes the machine to initialise
     Proof General.

 -- Variable: proof-splash-contents
     Evaluated to configure splash screen displayed when entering Proof
     General.
     A list of the screen contents.  If an element is a string or an
     image specifier, it is displayed centred on the window on its own
     line.  If it is nil, a new line is inserted.


File: PG-adapting.info,  Node: Global Constants,  Next: Handling Multiple Files,  Prev: Splash Screen Settings,  Up: Top

7 Global Constants
******************

The settings here are internal constants used by Proof General.  You
don't need to configure these for your proof assistant unless you want
to modify or extend the defaults.

 -- Variable: proof-general-name
     Proof General name used internally and in menu titles.

 -- User Option: proof-general-home-page
     Web address for Proof General.

     The default value is `"http://proofgeneral.inf.ed.ac.uk"'.

 -- Variable: proof-universal-keys
     List of key bindings made for all proof general buffers.
     Elements of the list are tuples `(k . f)' where `k' is a key
     binding (vector) and `f' the designated function.


File: PG-adapting.info,  Node: Handling Multiple Files,  Next: Configuring Editing Syntax,  Prev: Global Constants,  Up: Top

8 Handling Multiple Files
*************************

Large proof developments are typically spread across multiple files.
Many provers support such developments by keeping track of dependencies
and automatically processing scripts. Proof General supports this
mechanism. The user's point of view is considered in the user manual.
Here, we describe the more technical nitty gritty.  This is what you
need to know when you customise another proof assistant to work with
Proof General.

Documentation for the configuration settings mentioned here appears in
the previous sections, this section is intended to help explain the use
of those settings.

Proof General maintains a list `proof-included-files-list' of files
which it thinks have been processed by the proof assistant.  When a file
which is on this list is visited in Emacs, it will be coloured entirely
blue to indicate that it has been processed.  No editing of the file
will be allowed (unless `proof-strict-read-only' allows it).

 -- Variable: proof-included-files-list
     List of files currently included in proof process.
     This list contains files in canonical truename format (see
     ``file-truename'').

     Whenever a new file is being processed, it gets added to this list
     via the ``proof-shell-process-file'' configuration settings.  When
     the prover retracts a file, this list is resynchronised via the
     ``proof-shell-retract-files-regexp'' and
     ``proof-shell-compute-new-files-list'' configuration settings.

     Only files which have been *fully* processed should be included
     here.  Proof General itself will automatically add the filenames
     of a script buffer which has been completely read when scripting
     is deactivated.  It will automatically remove the filename of a
     script buffer which is completely unread when scripting is
     deactivated.

     NB: Currently there is no generic provision for removing files
     which are only partly read-in due to an error, so ideally the
     proof assistant should only output a processed message when a file
     has been successfully read.

The way that `proof-included-files-list' is maintained is the key to
multiple file management.  Ideally you should not set this variable
directly, but instead use (some of) the various configuration settings
that enable functionality inside Proof General for managing
`proof-included-files-list' (see below if the configuration setting do
not suffice).

There is a range of strategies for managing multiple files.  Ideally,
file dependencies should be managed by the proof assistant.  Proof
General will use the prover's low-level commands to process a whole file
and its requirements non-interactively, without going through script
management.  So that the user knows which files have been processed, the
proof assistant should issue messages which Proof General can recognize
("file `foo' has been processed") -- see `proof-shell-process-file'.
When the user wants to edit a file which has been processed, the file
must be retracted (unlocked).  The proof assistant should provide a
command corresponding to this action, which undoes a given file and all
its dependencies.  As each file is undone, a message should be issued
which Proof General can recognize ("file `foo' has been undone") - see
`proof-shell-retract-files-regexp'.  (The function
`proof-shell-compute-new-files-list' should be set to calculate the new
value for `proof-included-files-list' after a retract message has been
seen).

As well as this communication from the assistant to Proof General about
processed or retracted files, Proof General can communicate the other
way: it will tell the proof assistant when it has processed or retracted
a file via script management.  This is because during script management,
the proof assistant may not be aware that it is actually dealing with a
file of proof commands (rather than just terminal input).

Proof General will provide this information in two special instances.
First, when scripting is turned off in a file that has been completely
processed, Proof General will tell the proof assistant using
`proof-shell-inform-file-processed-cmd'.  Second, when scripting is
turned on in a file which is completely processed, Proof General will
tell the proof assistant to reconsider: the file should not be
considered completely processed yet.  This uses the setting
`proof-shell-inform-file-retracted-cmd'.  This second, retracting, case
might lead to a series of messages from the prover telling Proof
General to unlock files which depend on the present one, again via
`proof-shell-retract-files-regexp'.

The special case for retracting is the primary file the user wishes to
edit: this is automatically removed from `proof-included-files-list',
but it depends on the proof assistant whether or not it is possible to
revert to a partially processed version of the file (or "undo into"
it).  This is the reason for the setting
`proof-cannot-reopen-processed-files'.  If this is non-nil, any attempt
to undo a fully processed file will unlock the entire file (whether or
not Proof General itself has history information for the file).

What we have described so far is the ideal case, but it may require some
support from the proof assistant to set up (for example, if file-level
undo is not normally supported, or the messages during file processing
are not suitable).  Moreover, some proof assistants may not have file
handling with dependencies, or may have a particularly simple case of a
linear context: each file depends on all the ones processed before it.
Proof General allows you a shortcut to get automatic management of
multiple files in these cases by setting the flag
`proof-auto-multiple-files'.  This setting is probably an approximation
to the right thing for any proof assistant.  More files than necessary
will be retracted if the prover has a tree-like file dependency rather
than a linear one.

Finally, we should mention how Proof General recognizes file processing
messages from the proof assistant.  Proof General considers OUTPUT
delimited by the the two regular expressions
`proof-shell-eager-annotation-start' and
`proof-shell-eager-annotation-end' as being important. It displays the
OUTPUT in the Response buffer and analyses the contents further. Among
other important messages characterised by these regular expressions
(warnings, errors, or information), the prover can tell the interface
whenever it processes or retracts a file.

To summarize, the settings for multiple file management that may be
customized are as follows. To recognize file-processing,
`proof-shell-process-file'.  To recognize messages about file undoing,
`proof-shell-retract-files-regexp' and
`proof-shell-compute-new-files-list'.  *Note Settings for matching
urgent messages from proof process::.  To tell the prover about files
handled with script management, use
`proof-shell-inform-file-processed-cmd' and
`proof-shell-inform-file-retracted-cmd'.  *Note Proof shell commands::.
If your prover does not allow re-opening of closed files, set
`proof-cannot-reopen-processed-files' to `t'.    Finally, set the flag
`proof-auto-multiple-files' for a automatic approximation to multiple
file handling.  *Note Proof Script Settings::.

Internally Proof General uses
`proof-register-possibly-new-processed-file' to add a file to
`proof-included-files-list' and to possibly inform the prover about
this fact, *Note Proof script mode::. The function
`proof-shell-process-urgent-message-retract' is responsible for taking
(possibly several) files off `proof-included-files-list'. It relies on
`proof-shell-compute-new-files-list' (*note Settings for matching
urgent messages from proof process::) to compute the new value of
`proof-included-files-list' and then calls `proof-restart-buffers' on
all those buffers that have been taken off from
`proof-included-files-list', *Note Proof script mode::.


File: PG-adapting.info,  Node: Configuring Editing Syntax,  Next: Configuring Font Lock,  Prev: Handling Multiple Files,  Up: Top

9 Configuring Editing Syntax
****************************

Emacs has some standard settings which configure the syntax of major
modes.  The main setting is the syntax table, which determines the
syntax of programming elements such as strings, comments, and
parentheses.  To configure the syntax table, you can either write calls
to `modify-syntax-entry' in your mode functions, or set the following
variables to contain the tables for each mode.  (The main mode to be
concerned about is of course the proof script, where user editing takes
place).

 -- Variable: proof-script-syntax-table-entries
     List of syntax table entries for proof script mode.
     A flat list of the form
            (CHAR SYNCODE CHAR SYNCODE ...)
     See doc of ``modify-syntax-entry'' for details of characters and
     syntax codes.

     At present this is used only by the ``proof-easy-config'' macro.

 -- Variable: proof-shell-syntax-table-entries
     List of syntax table entries for proof script mode.
     A flat list of the form
            (CHAR SYNCODE CHAR SYNCODE ...)
     See doc of ``modify-syntax-entry'' for details of characters and
     syntax codes.

     At present this is used only by the ``proof-easy-config'' macro.
Some additional useful settings are:

 -- Variable: comment-quote-nested
     Non-nil if nested comments should be quoted.  This should be
     locally set by each major mode if needed.  The default setting is
     non-nil: modes which allow nested comments may set this to nil.

 -- Variable: outline-regexp
     Regular expression to match the beginning of a heading.  Any line
     whose beginning matches this regexp is considered to start a
     heading.

 -- Variable: outline-heading-end-regexp
     Regular expression to match the beginning of a heading.  Any line
     whose beginning matches this regexp is considered to start a
     heading.


File: PG-adapting.info,  Node: Configuring Font Lock,  Next: Configuring Tokens,  Prev: Configuring Editing Syntax,  Up: Top

10 Configuring Font Lock
************************

Support for Font Lock in Proof General is described in the user manual
(see the Syntax highlighting section).  To configure Font Lock for a
new proof assistant, you need to set the variable `font-lock-keywords'
in each of the mode functions you want highlighting for.  Proof General
will automatically install these settings, and use font lock minor mode
(for syntax highlighting as you type) in script buffers.

To understand its format, check the documentation of
`font-lock-keywords' inside Emacs.

Instead of setting `font-lock-keywords' in each mode function, you can
use the following four variables to make the settings in place.  This
is particularly useful if use the easy configuration mechanism for
Proof General, *note Demonstration instance and easy configuration::.

 -- Variable: proof-script-font-lock-keywords
     Value of ``font-lock-keywords'' used to fontify proof scripts.
     The proof script mode should set this before calling
     ``proof-config-done''.  Used also by ``proof-easy-config''
     mechanism.  See also ``proof-goals-font-lock-keywords'' and
     ``proof-response-font-lock-keywords''.

 -- Variable: proof-goals-font-lock-keywords
     Value of ``font-lock-keywords'' used to fontify the goals output.
     The goals shell mode should set this before calling
     ``proof-goals-config-done''.  Used also by ``proof-easy-config''
     mechanism.  See also ``proof-script-font-lock-keywords'' and
     ``proof-response-font-lock-keywords''.

 -- Variable: proof-response-font-lock-keywords
     Value of ``font-lock-keywords'' used to fontify the response
     output.
     The response mode should set this before calling
     ``proof-response-config-done''.  Used also by
     ``proof-easy-config'' mechanism.  See also
     ``proof-script-font-lock-keywords'' and
     ``proof-goals-font-lock-keywords''.
Proof General provides a special function, `proof-zap-commas', for
tweaking the font lock behaviour of provers which have declarations of
the form `x,y,z:Ty'.  This function removes highlighting on the commas,
and can be added as the last element of `font-lock-keywords'.  Further
manipulation of font lock behaviour can be achieved via two hook
functions which are run before and after fontifying the output buffers.

 -- Function: proof-zap-commas limit
     Remove the face of all `,' from point to LIMIT.
     Meant to be used from ``font-lock-keywords'' as a way to unfontify
     commas in declarations and definitions.  Useful for provers which
     have declarations of the form x,y,z:Ty All that can be said for it
     is that the previous ways of doing this were even more bogus....

 -- Variable: pg-before-fontify-output-hook
     This hook is called before fontifying a region in an output buffer.
     A function on this hook can alter the region of the buffer within
     the current restriction, and must return the final value of
     (`point-max').  [This hook is presently only used by
     phox-sym-lock].

 -- Variable: pg-after-fontify-output-hook
     This hook is called before fonfitying a region in an output buffer.
     [This hook is presently only used by Isabelle].


File: PG-adapting.info,  Node: Configuring Tokens,  Next: Configuring Proof-Tree Visualization,  Prev: Configuring Font Lock,  Up: Top

11 Configuring Tokens
*********************

Unicode Tokens is basically an overly complicated way of configuring
font-lock, along with some helpful menus.  The font lock configuration
makes use of recent Emacs features, particularly including
`compose-region' which allows the presentation of the buffer be
different from the underlying buffer contents.  Compared with the
X-Symbol package used previously by Proof General, this has the huge
advantage of not requiring the underlying text to be changed to display
symbols.

Usage of the Unicode Tokens package is described in the Proof General
user manual, *note (ProofGeneral)Unicode support::.

 -- Variable: proof-tokens-activate-command
     Command to activate token input/output for prover.
     If non-nil, this command is sent to the proof assistant when
     Unicode Tokens support is activated.

 -- Variable: proof-tokens-deactivate-command
     Command to deactivate token input/output for prover.
     If non-nil, this command is sent to the proof assistant when
     Unicode Tokens support is deactivated.
We expect tokens to be used uniformly, so that along with each script
mode buffer, the response buffer and goals buffer also invoke Tokens to
display special characters in the same token language.  This happens
automatically.  If you want additional modes to use Tokens with the
token language for your proof assistant, you can set
`proof-tokens-extra-modes'.

 -- Variable: proof-tokens-extra-modes
     List of additional mode names to use with Proof General tokens.
     These modes will have Tokens enabled for the proof assistant token
     language, in addition to the four modes for Proof General (script,
     shell, response, pbp).

     Set this variable if you want additional modes to also display
     tokens (for example, editing documentation or source code files).


File: PG-adapting.info,  Node: Configuring Proof-Tree Visualization,  Next: Writing More Lisp Code,  Prev: Configuring Tokens,  Up: Top

12 Configuring Proof-Tree Visualization
***************************************

The proof-tree visualization feature was written with the idea of
supporting Coq as well as other proof assistants. Nevertheless,
supporting proof-tree visualization for a second proof assistant will
almost certainly require changes in the generic Elisp code in
`generic/proof-tree.el' as well as in the Prooftree program.

* Menu:

* Prerequisites::
* Proof-Tree Display Internals::
* Configuring Prooftree for a New Proof Assistant::


File: PG-adapting.info,  Node: Prerequisites,  Next: Proof-Tree Display Internals,  Up: Configuring Proof-Tree Visualization

12.1 Prerequisites
==================

Proof-tree visualization requires certain support from the proof
assistant. Patching the proof assistant is therefore the first step of
adding support for proof-tree visualization. The following features are
needed.

Unique goal identification
     The proof assistant must assign and output a unique string for
     each goal. For Coq the internal `evar' index number is used, which
     is printed for each goal in the form `(ID XXX)' when Coq is
     started with the option `-emacs'.

     The unique goal identification is needed to distinguish newly
     spawned subgoals from older open subgoals and to mark the current
     goal in the proof-tree display.

Indication of newly generated subgoals
     A proof command that spawns additional subgoals must somehow
     indicate the goal ID's of these new subgoals. Otherwise the
     proof-tree display will not be able to reconstruct the proof-tree
     structure.

     For Coq the newly spawned subgoals appear always in the list of
     additional subgoals below the current goal. Note, that it is not
     required to mark the newly spawned subgoals. They may appear in a
     mixed list with older open subgoals. Note further, that it is not
     required that always the complete set of all open subgoals is
     printed (which is indeed not the case after of `Focus' command in
     Coq). It is only required that the goal ID's of all newly spawned
     subgoals is somehow printed.

State number for undo
     There must be a state number that is strictly increasing when
     asserting proof commands and that is reset to the appropriate
     number after retracting some proof commands.

     For Coq the state number in the extended prompt (visible only with
     option `-emacs') is used.

Information about existential variables
     Existential variables are placeholders that might or must be
     instantiated later in the proof. Prooftree supports existential
     variables with three features. Firstly, it can update goals when
     existential variables get instantiated. Secondly, it can mark the
     proof commands that introduced or instantiated existential
     variables and, thirdly, it can display and track dependencies
     between existential variables.

     For the first feature, the proof assistant must list the currently
     instantiated existential variables for every goal. For the second
     feature it must additionally list the not instantiated existential
     variables. Finally, for the third feature, it must display the
     dependencies for instantiated existential variables.

     For Coq, all necessary information is provided in the existential
     evar line, that is printed with the `-emacs' switch.



File: PG-adapting.info,  Node: Proof-Tree Display Internals,  Next: Configuring Prooftree for a New Proof Assistant,  Prev: Prerequisites,  Up: Configuring Proof-Tree Visualization

12.2 Proof-Tree Display Internals
=================================

This section gives some information about the inner structure of the
code that realizes the proof-tree display. The idea here is that this
section provides the background information to make the documentation
of the customizable variables of the proof-tree Elisp code easy to
understand.

* Menu:

* Organization of the Code::
* Communication::
* Guards::
* Urgent and Delayed Actions::
* Full Annotation::


File: PG-adapting.info,  Node: Organization of the Code,  Next: Communication,  Up: Proof-Tree Display Internals

12.2.1 Organization of the Code
-------------------------------

The proof-tree display is realized by Proof General in cooperation with
the external Prooftree program. The latter is a GTK application in
OCaml. Both, the Elisp code in Proof General and the Prooftree OCaml
code is divided into a generic and a proof assistant specific part.

The generic Elisp code lives in `generic/proof-tree.el'. As usual in
Proof General, it contains various customizable variables, which the
proof assistant specific code must set. Most of these variables contain
regular expressions, but there are also some that hold functions. The
Coq specific code for the proof-tree display is distributed in a few
chunks over `coq/coq.el'.

The main task of the Elisp code is to extract goals, undo events and
information about existential variables from the proof-assistant output
and to send all this data to Prooftree.  The Elisp code does also
determine if additional output must be requested from the proof
assistant. In that case it adds appropriate commands to
`proof-action-list', *note Proof script mode::. These additional
commands are flagged with `proof-tree-show-subgoal', `no-goals-display'
and `no-response-display'. The flag `proof-tree-show-subgoal' ensures
that a number of internal functions ignore these additional commands.
The other two flags ensure that their output is neither displayed in
the goals nor the response buffer.

For the decision about which goals must be sent to Prooftree, the Elisp
code maintains the following two state variables.

 -- Variable: proof-tree-sequent-hash
     Hash table to remember sequent ID's.
     Needed because some proof assistants do not distinguish between
     new subgoals, which have been created by the last proof command,
     and older, currently unfocussed subgoals. If Proof General meets a
     goal, it is treated as new subgoal if it is not in this hash yet.

     The hash is mostly used as a set of sequent ID's. However, for
     undo operations it is necessary to delete all those sequents from
     the hash that have been created in a state later than the undo
     state. For this purpose this hash maps sequent ID's to the state
     number in which the sequent has been created.

     The hash table is initialized in ``proof-tree-start-process''.

 -- Variable: proof-tree-existentials-alist
     Alist mapping existential variables to sequent ID's.
     Used to remember which goals need a refresh when an existential
     variable gets instantiated. To support undo commands the old
     contents of this list must be stored in
     ``proof-tree-existentials-alist-history''. To ensure undo is
     properly working, this variable should only be changed by using
     ``proof-tree-delete-existential-assoc'',
     ``proof-tree-add-existential-assoc'' or
     ``proof-tree-clear-existentials''.

When retracting these two variables must be set to their previous
state. For `proof-tree-sequent-hash' this is done with the state
numbers that are stored in the hash. For
`proof-tree-existentials-alist' a separate alist stores previous states.

 -- Variable: proof-tree-existentials-alist-history
     Alist mapping state numbers to old values of
     ``proof-tree-existentials-alist''.
     Needed for undo.

In Prooftree the separation between generic and proof-assistant
specific code is less obvious. The Coq specific code is in the file
`coq.ml'. All the remaining code is generic.

Prooftree opens for each proof a separate window. It reconstructs the
proof tree and orders the existential variables in a dependency
hierarchy. It stores a complete history of previous states to support
arbitrary undo operations. Under normal circumstances one starts just
one Prooftree process that keeps running for the remainder of the Proof
General session, regardless of how many proof-tree windows are
displayed.

A fair amount of the Prooftree code is documented with `ocamldoc'
documentation comments. With `make doc' they can be converted into a
set of html pages in the `doc' subdirectory.


File: PG-adapting.info,  Node: Communication,  Next: Guards,  Prev: Organization of the Code,  Up: Proof-Tree Display Internals

12.2.2 Communication
--------------------

Prooftree is a standard Emacs subprocess that reads goals and other
proof status messages from its standard input. The communication
between Proof General and Prooftree is almost one way only. Proof
General sends proof status messages to Prooftree, from which Prooftree
reconstructs the current proof status and the complete proof tree.
Prooftree never requests additional information from Proof General. The
only message that is sent from Prooftree to Proof General is a
`stop-displaying' command, when the user closes the proof-tree display
of the current proof.

The communication protocol is completely described in the `ocamldoc'
documentation of `input.ml' in the Prooftree sources. All messages
consist of UTF-8 encoded human-readable strings. The strings have
either a fixed length or their byte-length is encoded in the message
before the string itself.

For debugging purposes Prooftree can save all input in a file.  This
feature can be turned on in the `Debug' tab of the Prooftree
configuration dialog or with option `-tee'.


File: PG-adapting.info,  Node: Guards,  Next: Urgent and Delayed Actions,  Prev: Communication,  Up: Proof-Tree Display Internals

12.2.3 Guards
-------------

The proof-tree display code inside Proof General uses two guard
variables.

 -- Variable: proof-tree-configured
     Whether external proof-tree display is configured.
     This boolean enables the proof-tree menu entry and the function
     that starts external proof-tree display.

 -- Variable: proof-tree-external-display
     Display proof trees in external prooftree windows if t.
     Actually, if this variable is t then the user requested an
     external proof-tree display. If there was no unfinished proof when
     proof-tree display was requested and if no proof has been started
     since then, then there is obviously no proof-tree display. In this
     case, this variable stays t and the proof-tree display will be
     started for the next proof.

     Controlled by ``proof-tree-external-display-toggle''.

In Proof General, the code for the external proof-tree display is
called from the proof-shell filter function in `proof-shell-exec-loop'
and `proof-shell-filter-manage-output', *note Proof shell mode::. The
variable `proof-tree-external-display' is a guard for these calls, to
ensure that the proof-tree specific code is only called if the user
requested a proof-tree display.

The whole proof-tree package contains only one function that can be
called interactively: `proof-tree-external-display-toggle', which
switches `proof-tree-external-display' on and off. When
`proof-tree-configured' is `nil', `proof-tree-external-display-toggle'
aborts with an error message.

 -- Command: proof-tree-external-display-toggle
     Toggle the external proof-tree display.
     When called outside a proof the external proof-tree display will
     be enabled for the next proof. When called inside a proof the
     proof display will be created for the current proof. If the
     external proof-tree display is currently on, then this toggle will
     switch it off. At the end of the proof the proof-tree display is
     switched off.


File: PG-adapting.info,  Node: Urgent and Delayed Actions,  Next: Full Annotation,  Prev: Guards,  Up: Proof-Tree Display Internals

12.2.4 Urgent and Delayed Actions
---------------------------------

The proof-shell filter functions contains two calls to proof-tree
specific code. One for urgent actions and one for all remaining
actions, that can be delayed.

Urgent actions are those that must be executed before
`proof-shell-exec-loop' sends the next item from `proof-action-list' to
the proof assistant. For execution speed, the amount of urgent code
should be kept small.

 -- Function: proof-tree-urgent-action flags
     Handle urgent points before the next item is sent to the proof
     assistant.
     Schedule goal updates when existential variables have changed and
     call ``proof-tree-urgent-action-hook''. All this is only done if
     the current output does not come from a command (with the
     `'proof-tree-show-subgoal' flag) that this package inserted itself.

     Urgent actions are only needed if the external proof display is
     currently running. Therefore this function should not be called
     when ``proof-tree-external-display'' is nil.

     This function assumes that the prover output is not suppressed.
     Therefore, ``proof-tree-external-display'' being t is actually a
     necessary precondition.

     The not yet delayed output is in the region
     [`proof-shell-delayed-output-start',
     `proof-shell-delayed-output-end'].

The function `proof-tree-urgent-action' is called at a point where it
is save to manipulate `proof-action-list'. This is essential, because
`proof-tree-urgent-action' inserts goal display commands into
`proof-action-list' when existential variables got instantiated and
when the sequent text from newly created subgoals is missing.

Most of the proof-tree specific code runs when the proof assistant is
already busy with the next item from `proof-action-list'.

 -- Function: proof-tree-handle-delayed-output cmd flags span
     Process delayed output for prooftree.
     This function is the main entry point of the Proof General
     prooftree support. It examines the delayed output in order to take
     appropriate actions and maintains the internal state.

     All arguments are (former) fields of the ``proof-action-list''
     entry that is now finally retired. CMD is the command, FLAGS are
     the flags and SPAN is the span.

The function `proof-tree-handle-delayed-output' does all the
communication with Prooftree.


File: PG-adapting.info,  Node: Full Annotation,  Prev: Urgent and Delayed Actions,  Up: Proof-Tree Display Internals

12.2.5 Full Annotation
----------------------

In the default configuration Proof General switches the proof assistant
into quiet mode if there are more than `proof-shell-silent-threshold'
items in `proof-action-list', see Section Document centred working (in
Chapter Advanced Script Management and Editing) in the Proof General
users manual. The proof-tree display needs of course the full output
from the proof assistant.  Therefore `proof-shell-should-be-silent'
keeps the proof assistant noisy when the proof-tree display is switched
on.


File: PG-adapting.info,  Node: Configuring Prooftree for a New Proof Assistant,  Prev: Proof-Tree Display Internals,  Up: Configuring Proof-Tree Visualization

12.3 Configuring Prooftree for a New Proof Assistant
====================================================

To get the proof-tree display running for a new proof assistant one has
to configure the proof-tree Elisp code and adapt the Prooftree program.

* Menu:

* Proof Tree Elisp configuration::
* Prooftree Adaption::


File: PG-adapting.info,  Node: Proof Tree Elisp configuration,  Next: Prooftree Adaption,  Up: Configuring Prooftree for a New Proof Assistant

12.3.1 Proof Tree Elisp configuration
-------------------------------------

All variables that need to be configured are in the customization group
`proof-tree-internals'. Most of these variables are regular expressions
for extracting various parts from the proof assistant output. However,
some are functions that need to be implemented as prover specific part
of the proof display code.

The variables `proof-tree-configured', `proof-tree-get-proof-info' and
`proof-tree-find-begin-of-unfinished-proof' might be used before the
proof assistant is running inside a proof shell. They must therefore be
configured as part of the proof assistant editing mode.

The other variables are only used when the proof shell is running. They
can therefore be configured with the proof assistant proof-shell mode.


File: PG-adapting.info,  Node: Prooftree Adaption,  Prev: Proof Tree Elisp configuration,  Up: Configuring Prooftree for a New Proof Assistant

12.3.2 Prooftree Adaption
-------------------------

To make the new proof assistant known to Prooftree, the match in
function `configure_prooftree' in `input.ml' must be extended. If the
new proof assistant does not support existential variables adding a line
       | "new-pa-name" -> ()
suffices.

If the new prover supports existential variables, Prooftree must be
extended with a parser for the existential variable information
printout of the proof assistant. The parser for Coq is contained in the
file `coq.ml'. Then the function `configure_prooftree' must assign this
new parser to the reference `parse_existential_info'.


File: PG-adapting.info,  Node: Writing More Lisp Code,  Next: Internals of Proof General,  Prev: Configuring Proof-Tree Visualization,  Up: Top

13 Writing More Lisp Code
*************************

You may want to add some extra features to your instance of Proof
General which are not supported in the generic core.  To do this, you
can use the settings described above, plus a small number of fundamental
functions in Proof General which you can consider as exported in the
generic interface.  Be careful using more functions than are mentioned
here because the internals of Proof General may change between versions.

* Menu:

* Default values for generic settings::
* Adding prover-specific configurations::
* Useful variables::
* Useful functions and macros::


File: PG-adapting.info,  Node: Default values for generic settings,  Next: Adding prover-specific configurations,  Up: Writing More Lisp Code

13.1 Default values for generic settings
========================================

Several generic settings are defined using `defpgcustom' in
`proof-config.el'.  This introduces settings of the form `<PA>-name'
for each proof assistant PA.

To set the default value for these settings in prover-specific cases,
you should use the special `defpgdefault' macro:

 -- Macro: defpgdefault
     Set default for the proof assistant specific variable <PA>-SYM to
     VALUE.
     This should be used in prover-specific code to alter the default
     values for prover specific settings.

     Usage: (defpgdefault SYM VALUE)

In your prover-specific code you can simply use the setting `<PA>-sym'
directly, i.e., write `myprover-home-page'.

In the generic code, you can use a macro, writing `(proof-ass
home-page)' to refer to the `<PA>-home-page' setting for the currently
running instance of Proof General.

*Note Configuration variable mechanisms::, for more details on this
mechanism.


File: PG-adapting.info,  Node: Adding prover-specific configurations,  Next: Useful variables,  Prev: Default values for generic settings,  Up: Writing More Lisp Code

13.2 Adding prover-specific configurations
==========================================

Apart from the generic settings, your prover instance will probably need
some specific customizable settings.

Defining new prover-specific settings using customize is pretty easy.
You should do it at least for your prover-specific user options.

The code in `proof-site.el' provides each prover with two customization
groups automatically (based on the name of the assistant): `<PA>' for
user options for prover PA and `<PA>-config' for configuration of
prover PA.  Typically `<PA>-config' holds settings which are constants
but which may be nice to tweak.

The first group appears in the menu
       ProofGeneral -> Advanced -> Customize -> <PA>
The second group appears in the menu:
       ProofGeneral -> Internals -> <PA> config

A typical use of `defcustom' looks like this:
     (defcustom myprover-search-page
       "http://findtheorem.myprover.org"
       "URL of search web page for myprover."
       :type 'string
       :group 'myprover-config)
This introduces a new customizable setting, which you might use to make
a menu entry, for example.  The default value is the string
`"http://findtheorem.myprover.org"'.


File: PG-adapting.info,  Node: Useful variables,  Next: Useful functions and macros,  Prev: Adding prover-specific configurations,  Up: Writing More Lisp Code

13.3 Useful variables
=====================

In `proof-site', some architecture flags are defined.  These can be
used to write conditional pieces of code for different Emacs and
operating systems.  They are referred to mainly in `proof-compat'
(which helps to keep the architecture and version dependent code in one
place).

 -- Variable: proof-running-on-win32
     Non-nil if Proof General is running on a windows variant system.


File: PG-adapting.info,  Node: Useful functions and macros,  Prev: Useful variables,  Up: Writing More Lisp Code

13.4 Useful functions and macros
================================

The recommended functions you may invoke are these:

   * Any of the interactive commands (i.e. anything you  can invoke
     with `M-x', including all key-bindings)

   * Any of the internal functions and macros mentioned below

To insert text into the current (usually script) buffer, the function
`proof-insert' is useful.  There's also a handy macro
`proof-defshortcut' for defining shortcut functions using it.

 -- Function: proof-insert text
     Insert TEXT into the current buffer.
     TEXT may include these special characters:
            %p  - place the point here after input
     Any other %-prefixed character inserts itself.

 -- Macro: proof-defshortcut
     Define shortcut function FN to insert STRING, optional keydef KEY.
     This is intended for defining proof assistant specific functions.
     STRING is inserted using ``proof-insert'', which see.  KEY is
     added onto proof assistant map.
The function `proof-shell-invisible-command' is a useful utility for
sending a single command to the process.  You should use this to
implement user-level or internal functions rather than attempting to
directly manipulate the proof action list, or insert into the shell
buffer.

 -- Function: proof-shell-invisible-command cmd &optional wait
          invisiblecallback &rest flags
     Send CMD to the proof process.
     The CMD is `invisible' in the sense that it is not recorded in
     buffer.  CMD may be a string or a string-yielding expression.

     Automatically add ``proof-terminal-string'' if necessary, examining
     `proof-shell-no-auto-terminate-commands'.

     By default, let the command be processed asynchronously.  But if
     optional WAIT command is non-nil, wait for processing to finish
     before and after sending the command.

     In case CMD is (or yields) nil, do nothing.

     INVISIBLECALLBACK will be invoked after the command has finished,
     if it is set.  It should probably run the hook variables
     ``proof-state-change-hook''.

     FLAGS are additional flags to put onto the ``proof-action-list''.
     The flag `'invisible' is always added to FLAGS.

There are several handy macros to help you define functions which
invoke `proof-shell-invisible-command'.

 -- Macro: proof-definvisible
     Define function FN to send STRING to proof assistant, optional
     keydef KEY.
     This is intended for defining proof assistant specific functions.
     STRING is sent using ``proof-shell-invisible-command'', which see.
     STRING may be a string or a function which returns a string.  KEY
     is added onto proof assistant map.

 -- Macro: proof-define-assistant-command
     Define FN (docstring DOC) to send BODY to prover, based on CMDVAR.
     BODY defaults to CMDVAR, a variable.

 -- Macro: proof-define-assistant-command-witharg
     Define command FN to prompt for string CMDVAR to proof assistant.
     CMDVAR is a variable holding a function or string.  Automatically
     has history.

 -- Function: proof-format-filename string filename
     Format STRING by replacing quoted chars by escaped version of
     FILENAME.

     %e uses the canonicalized expanded version of filename (including
     directory, using ``default-directory'' - see ``expand-file-name'').

     %r uses the unadjusted (possibly relative) version of FILENAME.

     %m ('module') uses the basename of the file, without directory or
     extension.

     %s means the same as %e.

     Using %e can avoid problems with dumb proof assistants who don't
     understand ~, for example.

     For all these cases, the escapes in
     ``proof-shell-filename-escapes'' are processed.

     If STRING is in fact a function, instead invoke it on FILENAME and
     return the resulting (string) value.


File: PG-adapting.info,  Node: Internals of Proof General,  Next: Plans and Ideas,  Prev: Writing More Lisp Code,  Up: Top

14 Internals of Proof General
*****************************

This chapter sketches some of the internal functions and variables of
Proof General, to help developers who wish to understand or modify the
code.

Most of the documentation below is generated automatically from the
comments in the code.  Because Emacs lisp is interpreted and
self-documenting, the best way to find your way around the source is
inside Emacs once Proof General is loaded.  Read the source files, and
use functions such as `C-h v' and `C-h f'.

The code is split into files.  The following sections document the
important files, kept in the `generic/' subdirectory.

* Menu:

* Spans::
* Proof General site configuration::
* Configuration variable mechanisms::
* Global variables::
* Proof script mode::
* Proof shell mode::
* Debugging::


File: PG-adapting.info,  Node: Spans,  Next: Proof General site configuration,  Up: Internals of Proof General

14.1 Spans
==========

"Spans" are an abstraction of Emacs "overlays" originally used to help
bridge the gulf between GNU Emacs and XEmacs. See the file
`lib/span.el'. XEmacs calls these "extents" which is a name still used
in some parts of the code.


File: PG-adapting.info,  Node: Proof General site configuration,  Next: Configuration variable mechanisms,  Prev: Spans,  Up: Internals of Proof General

14.2 Proof General site configuration
=====================================

The file `proof-site.el' contains the initial configuration for Proof
General for the site (or user) and the choice of provers.

The first part of the configuration is to set `proof-home-directory' to
the directory that `proof-site.el' is located in, or to the variable of
the environment variable `PROOFGENERAL_HOME' if that is set.

 -- Variable: proof-home-directory
     Directory where Proof General is installed.  Ends with slash.
     Default value taken from environment variable `PROOFGENERAL_HOME'
     if set, otherwise based on where the file `proof-site.el' was
     loaded from.  You can use customize to set this variable.

Further directory variables allow the files of Proof General to be split
up and installed across a system if need be, rather than under the
`proof-home-directory' root.

 -- Variable: proof-images-directory
     Where Proof General image files are installed.  Ends with slash.

 -- Variable: proof-info-directory
     Where Proof General Info files are installed.  Ends with slash.

After defining these settings, we define a "mode stub" for each proof
assistant enabled.  The mode stub will autoload Proof General for the
right proof assistant when a file is visited with the corresponding
extension.  The proof assistants enabled are the ones listed in the
`proof-assistants' setting.

 -- User Option: proof-assistants
     Choice of proof assistants to use with Proof General.
     A list of symbols chosen from: `'isar' `'coq' `'phox' `'hol-light'
     `'pgshell' `'pgocaml' `'pghaskell'.  If nil, the default will be
     ALL available proof assistants.

     Each proof assistant defines its own instance of Proof General,
     providing session control, script management, etc.  Proof General
     will be started automatically for the assistants chosen here.  To
     avoid accidently invoking a proof assistant you don't have, only
     select the proof assistants you (or your site) may need.

     You can select which proof assistants you want by setting this
     variable before `proof-site.el' is loaded, or by setting the
     environment variable `PROOFGENERAL_ASSISTANTS' to the symbols you
     want, for example "lego isa".  Or you can edit the file
     `proof-site.el' itself.

     Note: to change proof assistant, you must start a new Emacs
     session.

     The default value is `nil'.

The file `proof-site.el' also defines a version variable.

 -- Variable: proof-general-version
     Version string identifying Proof General release.


File: PG-adapting.info,  Node: Configuration variable mechanisms,  Next: Global variables,  Prev: Proof General site configuration,  Up: Internals of Proof General

14.3 Configuration variable mechanisms
======================================

The file `proof-config.el' defines the configuration variables for
Proof General, including instantiation parameters and user options.  See
previous chapters for details of its contents.  Here we mention some
conventions for declaring user options.

Global user options and instantiation parameters are declared using
`defcustom' as usual.  User options should have ``*'' as the first
character of their docstrings (standard Emacs convention) and live in
the customize group `proof-user-options'.  See `proof-config.el' for
the groups for instantiation parameters.

User options which are generic (having separate instances for each
prover) and instantiation parameters (by definition generic) can be
declared using the special macro `defpgcustom'.  It is used in the same
way as `defcustom', except that the symbol declared will automatically
be prefixed by the current proof assistant symbol.

 -- Macro: defpgcustom
     Define a new customization variable <PA>-SYM for the current proof
     assistant.
     This is intended for defining settings which are useful for any
     prover, but which the user may require different values of across
     provers.

     The function proof-assistant-<SYM> is also defined, which can be
     used in the generic portion of Proof General to access the value
     for the current prover.

     Arguments are as for `defcustom', which see.  If a :group argument
     is not supplied, the setting will be added to the internal
     settings for the current prover (named <PA>-config).

In specific instances of Proof General, the macro `defpgdefault' can be
used to give a default value for a generic setting.

 -- Macro: defpgdefault
     Set default for the proof assistant specific variable <PA>-SYM to
     VALUE.
     This should be used in prover-specific code to alter the default
     values for prover specific settings.

     Usage: (defpgdefault SYM VALUE)

All new instantiation variables are best declared using the
`defpgcustom' mechanism (old code may be converted gradually).
Customizations which are liable to be different for different instances
of Proof General are also best declared in this way.  An example is the
use of X Symbol, controlled by `_PA_-x-symbol-enable', since it works
poorly or not at all with some provers.

To access the generic settings, the following four functions and macros
are useful.

 -- Macro: proof-ass
     Return the value for SYM for the current prover.
     This macro should only be invoked once a specific prover is
     engaged.

 -- Macro: proof-ass-sym
     Return the symbol for SYM for the current prover.  SYM not
     evaluated.
     This macro should only be called once a specific prover is known.

 -- Macro: proof-ass-symv
     Return the symbol for SYM for the current prover.  SYM evaluated.
     This macro should only be invoked once a specific prover is
     engaged.

If changing a user option setting amounts to more than just setting a
variable (it may have some dynamic effect), we can set the `custom-set'
property for the variable to the function `proof-set-value' which does
an ordinary `set-default' to set the variable, and then calls a
function with the same name as the variable, to do whatever is
necessary according to the new value for the variable.

There are several settings which can be switched on or off by the user,
which use this `proof-set-value' mechanism.  They are controlled by
boolean variables with names like `proof-FOO-enable', and appear at the
start of the customize group `proof-user-options'.  They should be
edited by the user through the customization mechanism, and set in the
code using `customize-set-variable'.

In `proof-utils.el' there is a handy macro, `proof-deftoggle', which
constructs an interactive function for toggling boolean customize
settings.  We can use this to make an interactive function
`proof-FOO-toggle' to put on a menu or bind to a key, for example.

This general scheme is followed as far as possible, to give uniform
behaviour and appearance for boolean user options, as well as
interfacing properly with the `customize' mechanism.

 -- Function: proof-set-value sym value
     Set a customize variable using ``set-default'' and a function.
     We first call ``set-default'' to set SYM to VALUE.  Then if there
     is a function SYM (i.e. with the same name as the variable SYM),
     it is called to take some dynamic action for the new setting.

     If there is no function SYM, we try stripping
     ``proof-assistant-symbol'' and adding "proof-" instead to get a
     function name.  This extends `proof-set-value' to work with
     generic individual settings.

     The dynamic action call only happens when values *change*: as an
     approximation we test whether proof-config is fully-loaded yet.

 -- Macro: proof-deftoggle
     Define a function VAR-toggle for toggling a boolean customize
     setting VAR.
     The toggle function uses ``customize-set-variable'' to change the
     variable.  OTHERNAME gives an alternative name than the default
     <VAR>-toggle.  The name of the defined function is returned.


File: PG-adapting.info,  Node: Global variables,  Next: Proof script mode,  Prev: Configuration variable mechanisms,  Up: Internals of Proof General

14.4 Global variables
=====================

Global variables are defined in `proof.el'.  The same file defines a
few utility functions and some triggers to load in the other files.

 -- Variable: proof-script-buffer
     The currently active scripting buffer or nil if none.

 -- Variable: proof-shell-buffer
     Process buffer where the proof assistant is run.

 -- Variable: proof-response-buffer
     The response buffer.

 -- Variable: proof-goals-buffer
     The goals buffer.

 -- Variable: proof-buffer-type
     Symbol for the type of this buffer: `'script', `'shell', `'goals',
     or `'response'.

 -- Variable: proof-included-files-list
     List of files currently included in proof process.
     This list contains files in canonical truename format (see
     ``file-truename'').

     Whenever a new file is being processed, it gets added to this list
     via the ``proof-shell-process-file'' configuration settings.  When
     the prover retracts a file, this list is resynchronised via the
     ``proof-shell-retract-files-regexp'' and
     ``proof-shell-compute-new-files-list'' configuration settings.

     Only files which have been *fully* processed should be included
     here.  Proof General itself will automatically add the filenames
     of a script buffer which has been completely read when scripting
     is deactivated.  It will automatically remove the filename of a
     script buffer which is completely unread when scripting is
     deactivated.

     NB: Currently there is no generic provision for removing files
     which are only partly read-in due to an error, so ideally the
     proof assistant should only output a processed message when a file
     has been successfully read.

 -- Variable: proof-shell-proof-completed
     Flag indicating that a completed proof has just been observed.
     If non-nil, the value counts the commands from the last command of
     the proof (starting from 1).

 -- Variable: proof-shell-error-or-interrupt-seen
     Flag indicating that an error or interrupt has just occurred.
     Set to `'error' or `'interrupt' if one was observed from the proof
     assistant during the last group of commands.


File: PG-adapting.info,  Node: Proof script mode,  Next: Proof shell mode,  Prev: Global variables,  Up: Internals of Proof General

14.5 Proof script mode
======================

The file `proof-script.el' contains the main code for proof script
mode, as well as definitions of menus, key-bindings, and user-level
functions.

Proof scripts have two important variables for the locked and queue
regions.  These variables are local to each script buffer (although we
only really need one queue span in total rather than one per buffer).

 -- Variable: proof-locked-span
     The locked span of the buffer.
     Each script buffer has its own locked span, which may be detached
     from the buffer.  Proof General allows buffers in other modes also
     to be locked; these also have a non-nil value for this variable.

 -- Variable: proof-queue-span
     The queue span of the buffer.  May be detached if inactive or
     empty.
     Each script buffer has its own queue span, although only the active
     scripting buffer may have an active queue span.

Various utility functions manipulate and examine the spans.  An
important one is `proof-init-segmentation'.

 -- Function: proof-init-segmentation
     Initialise the queue and locked spans in a proof script buffer.
     Allocate spans if need be.  The spans are detached from the
     buffer, so the regions are made empty by this function.  Also
     clear list of script portions.

For locking files loaded by a proof assistant, we use the next function.

 -- Function: proof-complete-buffer-atomic buffer
     Ensure BUFFER marked completely processed, completing with a
     single step.

     If buffer already contains a locked region, only the remainder of
     the buffer is closed off atomically (although undo for the initial
     portion is unlikely to work, the decoration may be worth
     retaining).

     This works for buffers which are not in proof scripting mode too,
     to allow other files loaded by proof assistants to be marked
     read-only.

Atomic locking is instigated by the next function, which uses the
variables `proof-included-files-list' documented earlier (*note
Handling Multiple Files:: and *note Global variables::).

 -- Function: proof-register-possibly-new-processed-file file &optional
          informprover noquestions
     Register a possibly new FILE as having been processed by the
     prover.

     If INFORMPROVER is non-nil, the proof assistant will be told about
     this, to co-ordinate with its internal file-management.
     (Otherwise we assume that it is a message from the proof assistant
     which triggers this call).  In this case, the user will be queried
     to save some buffers, unless NOQUESTIONS is non-nil.

     No action is taken if the file is already registered.

     A warning message is issued if the register request came from the
     proof assistant and Emacs has a modified buffer visiting the file.

(Unlocking is done by `proof-shell-process-urgent-message-retract'
together with `proof-restart-buffers'.)

An important pair of functions activate and deactivate scripting for the
current buffer.  A change in the state of active scripting can trigger
various actions, such as starting up the proof assistant, or altering
`proof-included-files-list'.

 -- Command: proof-activate-scripting &optional nosaves queuemode
     Ready prover and activate scripting for the current script buffer.

     The current buffer is prepared for scripting.  No changes are
     necessary if it is already in Scripting minor mode.  Otherwise, it
     will become the new active scripting buffer, provided scripting
     can be switched off in the previous active scripting buffer with
     ``proof-deactivate-scripting''.

     Activating a new script buffer is a good time to ask if the user
     wants to save some buffers; this is done if the user option
     ``proof-query-file-save-when-activating-scripting'' is set and
     provided the optional argument NOSAVES is non-nil.

     The optional argument QUEUEMODE relaxes the test for a busy proof
     shell to allow one which has mode QUEUEMODE.  In all other cases,
     a proof shell busy error is given.

     Finally, the hooks ``proof-activate-scripting-hook'' are run.
     This can be a useful place to configure the proof assistant for
     scripting in a particular file, for example, loading the correct
     theory, or whatever.  If the hooks issue commands to the proof
     assistant (via ``proof-shell-invisible-command'') which result in
     an error, the activation is considered to have failed and an error
     is given.

 -- Command: proof-deactivate-scripting &optional forcedaction
     Try to deactivate scripting for the active scripting buffer.

     Aims to set ``proof-script-buffer'' to nil and turn off the
     modeline indicator.  No action is required there is no active
     scripting buffer.

     We make sure that the active scripting buffer either has no locked
     region or a full locked region (everything in it has been
     processed).  If this is not already the case, we question the user
     whether to retract or assert, or automatically take the action
     indicated in the user option
     ``proof-auto-action-when-deactivating-scripting''.

     If ``proof-no-fully-processed-buffer'' is t there is only the
     choice to fully retract the active scripting buffer. In this case
     the active scripting buffer is retracted even if it was fully
     processed.  Setting
     ``proof-auto-action-when-deactivating-scripting'' to `'process' is
     ignored in this case.

     If the scripting buffer is (or has become) fully processed, and it
     is associated with a file, it is registered on
     ``proof-included-files-list''.  Conversely, if it is (or has
     become) empty, we make sure that it is *not* registered.  This is
     to be certain that the included files list behaves as we might
     expect with respect to the active scripting buffer, in an attempt
     to harmonize mixed scripting and file reading in the prover.

     This function either succeeds, fails because the user refused to
     process or retract a partly finished buffer, or gives an error
     message because retraction or processing failed.  If this function
     succeeds, then ``proof-script-buffer'' is nil afterwards.

     The optional argument FORCEDACTION overrides the user option
     ``proof-auto-action-when-deactivating-scripting'' and prevents
     questioning the user.  It is used to make a value for the
     ``kill-buffer-hook'' for scripting buffers, so that when a
     scripting buffer is killed it is always retracted.

The function `proof-segment-up-to' is the main one used for parsing the
proof script buffer.  There are several variants of this function
available corresponding to different parsing strategies; the appropriate
one is aliased to `proof-segment-up-to' according to which
configuration variables have been set.
   * If `proof-script-sexp-commands' is set, the choice is
     `proof-script-generic-parse-sexp'.   item If only
     `proof-script-command-end-regexp' or `proof-terminal-string' are
     set,  then the default is `proof-script-generic-parse-cmdend'.

   * If `proof-script-command-start-regexp' is set, the choice is
     `proof-script-generic-parse-cmdstart'.
The function `proof-semis-to-vanillas' uses `proof-segment-up-to' to
convert a parsed region of the script into a series of commands to be
sent to the proof assistant.

 -- Function: proof-script-generic-parse-cmdend
     For ``proof-script-parse-function'' if
     ``proof-script-command-end-regexp'' set.

 -- Function: proof-script-generic-parse-cmdstart
     For ``proof-script-parse-function'' if
     ``proof-script-command-start-regexp'' is set.

 -- Function: proof-script-generic-parse-sexp
     Used for ``proof-script-parse-function'' if
     ``proof-script-sexp-commands'' is set.

 -- Function: proof-semis-to-vanillas semis &optional queueflags
     Create vanilla spans for SEMIS and a list for the queue.
     Proof terminator positions SEMIS has the form returned by the
     function `proof-segment-up-to'.  The argument list is destroyed.
     The callback in each queue element is ``proof-done-advancing''.

     If the variable ``proof-script-preprocess'' is set (to the name of
     a function), call that function to construct the first element of
     each queue item.

     The optional QUEUEFLAGS are added to each queue item.

The function `proof-assert-until-point' is the main one used to process
commands in the script buffer.  It's actually used to implement the
assert-until-point, electric terminator keypress, and
find-next-terminator behaviours.  In different cases we want different
things, but usually the information (i.e. are we inside a comment) isn't
available until we've actually run `proof-segment-up-to (point)', hence
all the different options when we've done so.

 -- Function: proof-assert-until-point &optional displayflags
     Process the region from the end of the locked-region until point.

The main command for retracting parts of a script is
`proof-retract-until-point'.

 -- Function: proof-retract-until-point &optional undo-action
          displayflags
     Set up the proof process for retracting until point.
     This calculates the commands to undo to the current point within
     the locked region.  If invoked outside the locked region, undo the
     last successfully processed command.  See ``proof-retract-target''.

     After retraction has succeeded in the prover, the filter will call
     ``proof-done-retracting''.  If UNDO-ACTION is non-nil, it will
     then be invoked on the region in the proof script corresponding to
     the proof command sequence.  DISPLAYFLAGS control output shown to
     user, see ``proof-action-list''.

     Before the retraction is calculated, we enforce the file-level
     protocol with ``proof-activate-scripting''.  This has a couple of
     effects:

     1. If the file is completely processed, we have to re-open it for
     scripting again which may involve retracting other (dependent)
     files.

     2. We may query the user whether to save some buffers.

     Step 2 may seem odd - we're undoing (in) the buffer, after all -
     but what may happen is that when scripting starts going forward
     again, we hit a command that loads other files, but the user
     hasn't saved the latest edits.  Therefore it is right to query
     saves here.

To clean up when scripting is stopped, a script buffer is killed, a
file is retract (and thus must be unlocked), or the proof assistant
exits, we use the functions `proof-restart-buffers' and
`proof-script-remove-all-spans-and-deactivate'.

 -- Function: proof-restart-buffers buffers
     Remove all extents in BUFFERS and maybe reset
     ``proof-script-buffer''.
     The high-level effect is that all members of BUFFERS are
     completely unlocked, including all the necessary cleanup. No
     effect on a buffer which is nil or killed. If one of the buffers
     is the current scripting buffer, then ``proof-script-buffer'' will
     deactivated.

 -- Function: proof-script-remove-all-spans-and-deactivate
     Remove all spans from scripting buffers via
     ``proof-restart-buffers''.


File: PG-adapting.info,  Node: Proof shell mode,  Next: Debugging,  Prev: Proof script mode,  Up: Internals of Proof General

14.6 Proof shell mode
=====================

The proof shell mode code is in the file `proof-shell.el'.  Proof shell
mode is defined to inherit from `scomint-mode' using
`define-derived-mode' near the end of the file.  The `scomint.el'
package stands for "simplified comint", where `comint-mode' is the
standard Emacs mode for running an embedded command interpreter.  In
`scomint', many of the interactive commands have been removed to speed
up the process handling, because it isn't intended that the user
interacts directly with the shell in Proof General.

The bulk of the code in the `proof-shell' package is concerned with
sending code to and from the shell, and processing output for the
associated buffers (goals and response).

Good process handling is a tricky issue.  Proof General attempts to
manage the process strictly, by maintaining a queue of commands to send
to the process.  Once a command has been processed, another one is
popped off the queue and sent.

There are several important internal variables which control
interaction with the process.

 -- Variable: proof-shell-busy
     A lock indicating that the proof shell is processing.

     The lock notes that we are processing a queue of commands being
     sent to the prover, and indicates whether the commands correspond
     to script management from a buffer (rather than being ad-hoc query
     commands to the prover).

     When processing commands from a buffer for script management, this
     will be set to the queue mode `'advancing' or `'retracting' to
     indicate the direction of movement.

     When this is non-nil, ``proof-shell-ready-prover'' will give an
     error if called with a different requested queue mode.

     See also functions ``proof-activate-scripting'' and
     ``proof-shell-available-p''.

 -- Variable: proof-marker
     Marker in proof shell buffer pointing to previous command input.

 -- Variable: proof-action-list
     The main queue of things to do: spans, commands and actions.
     The value is a list of lists of the form
             (SPAN COMMANDS ACTION [DISPLAYFLAGS])
     which is the queue of things to do.

     SPAN is a region in the sources, where COMMANDS come from. Often,
     additional properties are recorded as properties of SPAN.

     COMMANDS is a list of strings, holding the text to be send to the
     prover. It might be the empty list if nothing needs to be sent to
     the prover, such as, for comments. Usually COMMANDS contains just
     1 string, but it might also contains more elements.  The text
     should be obtained with `(mapconcat 'identity COMMANDS " ")',
     where the last argument is a space.

     ACTION is the callback to be invoked when this item has been
     processed by the prover. For normal scripting items it is
     ``proof-done-advancing'', for retract items
     ``proof-done-retracting'', but there are more possibilities (e.g.
     ``proof-done-invisible'', ``proof-shell-set-silent'',
     ``proof-shell-clear-silent'' and
     ``proof-tree-show-goal-callback'').

     The DISPLAYFLAGS are set for non-scripting commands or for when
     scripting should not bother the user.  They may include
            `'invisible'                non-script command (``proof-shell-invisible-command'')
            `'no-response-display'      do not display messages in *response* buffer
            `'no-error-display'         do not display errors/take error action
            `'no-goals-display'         do not goals in *goals* buffer
            `'proof-tree-show-subgoal'  item inserted by the proof-tree package
     Note that `'invisible' does not imply any of the others. If flags
     are non-empty, interactive cues will be surpressed. (E.g.,
     printing hints).

     See the functions ``proof-start-queue'' and
     ``proof-shell-exec-loop''.

 -- Variable: pg-subterm-anns-use-stack
     Choice of syntax tree encoding for terms.

     If nil, prover is expected to make no optimisations.  If non-nil,
     the pretty printer of the prover only reports local changes.  For
     LEGO 1.3.1 use nil, for Coq 6.2, use t.

The function `proof-shell-start' is used to initialise a shell buffer
and the associated buffers.

 -- Command: proof-shell-start
     Initialise a shell-like buffer for a proof assistant.
     Does nothing if proof assistant is already running.

     Also generates goal and response buffers.

     If ``proof-prog-name-ask'' is set, query the user for the process
     command.

The function `proof-shell-kill-function' performs the converse function
of shutting things down; it is used as a hook function for
`kill-buffer-hook'.  Then no harm occurs if the user kills the shell
directly, or if it is done more cautiously via `proof-shell-exit'.  The
function `proof-shell-restart' allows a less drastic way of restarting
scripting, other than killing and restarting the process.

 -- Function: proof-shell-kill-function
     Function run when a proof-shell buffer is killed.
     Try to shut down the proof process nicely and clear locked regions
     and state variables.  Value for ``kill-buffer-hook'' in shell
     buffer, called by ``proof-shell-bail-out'' if process exits.

 -- Command: proof-shell-exit &optional dont-ask
     Query the user and exit the proof process.

     This simply kills the ``proof-shell-buffer'' relying on the hook
     function

     ``proof-shell-kill-function'' to do the hard work. If optional
     argument DONT-ASK is non-nil, the proof process is terminated
     without confirmation.

     The kill function uses `<PA>-quit-timeout' as a timeout to wait
     after sending ``proof-shell-quit-cmd'' before rudely killing the
     process.

     This function should not be called if
     ``proof-shell-exit-in-progress'' is t, because a recursive call of
     ``proof-shell-kill-function'' will give strange errors.

 -- Function: proof-shell-bail-out process event
     Value for the process sentinel for the proof assistant PROCESS.
     If the proof assistant dies, run ``proof-shell-kill-function'' to
     cleanup and remove the associated buffers.  The shell buffer is
     left around so the user may discover what killed the process.
     EVENT is the string describing the change.

 -- Command: proof-shell-restart
     Clear script buffers and send ``proof-shell-restart-cmd''.
     All locked regions are cleared and the active scripting buffer
     deactivated.

     If the proof shell is busy, an interrupt is sent with
     ``proof-interrupt-process'' and we wait until the process is ready.

     The restart command should re-synchronize Proof General with the
     proof assistant, without actually exiting and restarting the proof
     assistant process.

     It is up to the proof assistant how much context is cleared: for
     example, theories already loaded may be "cached" in some way, so
     that loading them the next time round only performs a re-linking
     operation, not full re-processing.  (One way of caching is via
     object files, used by Lego and Coq).

14.6.1 Input to the shell
-------------------------

Input to the proof shell via the queue region is managed by the
functions `proof-extend-queue' and `proof-shell-exec-loop'.

 -- Function: proof-extend-queue end queueitems
     Extend the current queue with QUEUEITEMS, queue end END.
     To make sense, the commands should correspond to processing actions
     for processing a region from (buffer-queue-or-locked-end) to END.
     The queue mode is set to `'advancing'

 -- Function: proof-extend-queue end queueitems
     Extend the current queue with QUEUEITEMS, queue end END.
     To make sense, the commands should correspond to processing actions
     for processing a region from (buffer-queue-or-locked-end) to END.
     The queue mode is set to `'advancing'

 -- Function: proof-shell-exec-loop
     Main loop processing the ``proof-action-list'', called from shell
     filter.

     ``proof-action-list'' contains a list of (SPAN COMMAND ACTION
     [FLAGS]) lists.

     If this function is called with a non-empty ``proof-action-list'',
     the head of the list is the previously executed command which
     succeeded.  We execute the callback (ACTION SPAN) on the first
     item, then (ACTION SPAN) on any following items which have null as
     their cmd components.

     If a there is a next command after that, send it to the process.

     If the action list becomes empty, unlock the process and remove
     the queue region.

     The return value is non-nil if the action list is now empty or
     contains only invisible elements for Prooftree synchronization.

Input is actually inserted into the shell buffer and sent to the process
by the low-level function `proof-shell-insert'.

 -- Function: proof-shell-insert strings action &optional scriptspan
     Insert STRINGS at the end of the proof shell, call
     ``scomint-send-input''.

     STRINGS is a list of strings (which will be concatenated), or a
     single string.

     The ACTION argument is a symbol which is typically the name of a
     callback for when each string has been processed.

     This calls ``proof-shell-insert-hook''.  The arguments `action' and
     `scriptspan' may be examined by the hook to determine how to modify
     the `string' variable (exploiting dynamic scoping) which will be
     the command actually sent to the shell.

     Note that the hook is not called for the empty (null) string or a
     carriage return.

     We strip the string of carriage returns before inserting it and
     updating ``proof-marker'' to point to the end of the newly
     inserted text.

     Do not use this function directly, or output will be lost.  It is
     only used in ``proof-add-to-queue'' when we start processing a
     queue, and in ``proof-shell-exec-loop'', to process the next item.

When Proof General is processing a queue of commands, the lock is
managed using a couple of utility functions.  You should not need to
use these directly.

 -- Function: proof-grab-lock &optional queuemode
     Grab the proof shell lock, starting the proof assistant if need be.
     Runs ``proof-state-change-hook'' to notify state change.  If
     QUEUEMODE is supplied, set the lock to that value.

 -- Function: proof-release-lock
     Release the proof shell lock.  Clear ``proof-shell-busy''.

14.6.2 Output from the shell
----------------------------

Two main functions deal with output, `proof-shell-classify-output' and
`proof-shell-process-urgent-message'.  In effect we consider the output
to be two streams intermingled: the "urgent" messages which have
"eager" annotations, as well as the ordinary ruminations from the
prover.

The idea is to conceal as much irrelevant information from the user as
possible; only the remaining output between prompts and after the last
urgent message will be a candidate for the goal or response buffer.  The
internal variable `proof-shell-urgent-message-marker' tracks the last
urgent message seen.

When output is grabbed from the prover process, the first action is to
strip spurious carriage return characters from the end of lines, if
`proof-shell-strip-crs-from-output' requires it.  Then the output is
stored into `proof-shell-last-output', and its type is stored in
`proof-shell-last-output-kind'.  Output which is deferred or possibly
discarded until the queue is empty is copied into
`proof-shell-delayed-output', with type
`proof-shell-delayed-output-kind'.  A record of the last prompt seen
from the prover process is also kept, in `proof-shell-last-prompt'.

 -- Variable: proof-shell-strip-crs-from-output
     If non-nil, remove carriage returns (^M) at the end of lines from
     output.
     This is enabled for cygwin32 systems by default.  You should turn
     it off if you don't need it (slight speed penalty).

 -- Variable: proof-shell-last-prompt
     A raw record of the last prompt seen from the proof system.
     This is the string matched by
     ``proof-shell-annotated-prompt-regexp''.

 -- Variable: proof-shell-last-output
     A record of the last string seen from the proof system.
     This is raw string, for internal use only.

 -- Variable: proof-shell-last-output-kind
     A symbol denoting the type of the last output string from the
     proof system.
     Specifically:
           `'interrupt'      An interrupt message
           `'error'          An error message
           `'loopback'       A command sent from the PA to be inserted into the script
           `'response'       A response message
           `'goals'          A goals (proof state) display
           `'systemspecific' Something specific to a particular system,
                            -- see ``proof-shell-handle-output-system-specific''
     The output corresponding to this will be in
     ``proof-shell-last-output''.

     See also ``proof-shell-proof-completed'' for further information
     about the proof process output, when ends of proofs are spotted.

     This variable can be used for instance specific functions which
     want to examine ``proof-shell-last-output''.

 -- Variable: proof-shell-last-output-kind
     A symbol denoting the type of the last output string from the
     proof system.
     Specifically:
           `'interrupt'      An interrupt message
           `'error'          An error message
           `'loopback'       A command sent from the PA to be inserted into the script
           `'response'       A response message
           `'goals'          A goals (proof state) display
           `'systemspecific' Something specific to a particular system,
                            -- see ``proof-shell-handle-output-system-specific''
     The output corresponding to this will be in
     ``proof-shell-last-output''.

     See also ``proof-shell-proof-completed'' for further information
     about the proof process output, when ends of proofs are spotted.

     This variable can be used for instance specific functions which
     want to examine ``proof-shell-last-output''.

 -- Variable: proof-shell-delayed-output-start
     A record of the start of the previous output in the shell buffer.
     The previous output is held back for processing at end of queue.

 -- Variable: proof-shell-delayed-output-end
     A record of the start of the previous output in the shell buffer.
     The previous output is held back for processing at end of queue.

 -- Variable: proof-shell-delayed-output-flags
     A copy of the ``proof-action-list'' flags for
     `proof-shell-delayed-output'.

 -- Function: proof-shell-handle-immediate-output cmd start end flags
     See if the output between START and END must be dealt with
     immediately.
     To speed up processing, PG tries to avoid displaying output that
     the user will not have a chance to see.  Some output must be
     handled immediately, however: these are errors, interrupts, goals
     and loopbacks (proof step hints/proof by pointing results).

     In this function we check, in turn:
            ``proof-shell-interrupt-regexp''
            ``proof-shell-error-regexp''
            ``proof-shell-proof-completed-regexp''
            ``proof-shell-result-start''
     Other kinds of output are essentially display only, so only dealt
     with if necessary.

     To extend this, set ``proof-shell-handle-output-system-specific'',
     which is a hook to take particular additional actions.

     This function sets variables: ``proof-shell-last-output-kind'',
     and the counter ``proof-shell-proof-completed'' which counts
     commands after a completed proof.

 -- Function: proof-shell-handle-delayed-output
     Display delayed goals/responses, when queue is stopped or
     completed.
     This function handles the cases of `proof-shell-output-kind' which
     are not dealt with eagerly during script processing, namely
     `'response' and `'goals' types.

     This is useful even with empty delayed output as it will empty the
     buffers.

     The delayed output is in the region
     [`proof-shell-delayed-output-start',`proof-shell-delayed-output-end'].

     If no goals classified output is found, the whole output is
     displayed in the response buffer.

     If goals output is found, the last matching instance, possibly
     bounded by ``proof-shell-end-goals-regexp'', will be displayed in
     the goals buffer (and may be further analysed by Proof General).

     Any output that appears *before* the last goals output (but after
     messages classified as urgent, see ``proof-shell-filter'') will
     also be displayed in the response buffer.

     For example, if OUTPUT has this form:
            MESSSAGE-1
            GOALS-1
            MESSAGE-2
            GOALS-2
            JUNK
     then GOALS-2 will be displayed in the goals buffer, and MESSAGE-2
     in the response buffer.  JUNK will be ignored.

     Notice that the above alternation (and separation of JUNK) can
     only be distinguished if both ``proof-shell-start-goals-regexp''
     and ``proof-shell-end-goals-regexp'' are set.  With just the start
     goals regexp set, GOALS-2 JUNK will appear in the goals buffer and
     no response output would occur.
     The goals and response outputs are copied into
     ``proof-shell-last-goals-output'' and
     ``proof-shell-last-response-output'' respectively.

     The value returned is the value for
     ``proof-shell-last-output-kind'', i.e., `'goals' or `'response'.

 -- Variable: proof-shell-urgent-message-marker
     Marker in proof shell buffer pointing to end of last urgent
     message.

 -- Function: proof-shell-process-urgent-message start end
     Analyse urgent message between START and END for various cases.

     Cases are: *trace* output, included/retracted files, cleared
     goals/response buffer, variable setting, xml-encoded PGIP response,
     theorem dependency message or interactive output indicator.

     If none of these apply, display the text between START and END.

     The text between START and END should be a string that starts with
     text matching ``proof-shell-eager-annotation-start'' and ends with
     text matching ``proof-shell-eager-annotation-end''.

The main processing point which triggers other actions is
`proof-shell-filter'.

 -- Function: proof-shell-filter str
     Master filter for the proof assistant shell-process.
     A function for ``scomint-output-filter-functions''.

     Deal with output STR and issue new input from the queue.  This is
     an important internal function.

     Handle urgent messages first.  As many as possible are processed,
     using the function ``proof-shell-process-urgent-messages''.

     If a prompt is seen, run ``proof-shell-filter-manage-output'' on
     the output between the new prompt and the last input (position of
     ``proof-marker'') or the last urgent message (position of
     ``proof-shell-urgent-message-marker''), whichever is later.  For
     example, in this case:
           PROMPT> INPUT
           OUTPUT-1
           URGENT-MESSAGE-1
           OUTPUT-2
           URGENT-MESSAGE-2
           OUTPUT-3
           PROMPT>
     ``proof-marker'' points after INPUT.

     ``proof-shell-urgent-message-marker'' points after
     URGENT-MESSAGE-2, after both urgent messages have been processed by
     ``proof-shell-process-urgent-messages''.  Urgent messages always
     processed; they are intended to correspond to informational notes
     that the prover makes to inform the user or interface on progress.

     In this case, the ordinary outputs OUTPUT-1 and OUTPUT-2 are
     ignored; only OUTPUT-3 will be processed by
     ``proof-shell-filter-manage-output''.

     Error or interrupt messages are expected to terminate an
     interactive output and appear last before a prompt and will always
     be processed.  Error messages and interrupt messages are therefore
     *not* considered as urgent messages.

     The first time that a prompt is seen, ``proof-marker'' is
     initialised to the end of the prompt.  This should correspond with
     initializing the process.  After that, ``proof-marker'' is only
     changed when input is sent in ``proof-shell-insert''.

 -- Function: proof-shell-filter-manage-output start end
     Subroutine of ``proof-shell-filter'' for output between START and
     END.

     First, we invoke ``proof-shell-handle-immediate-output'' which
     classifies and handles output that must be dealt with immediately.

     Other output (user display) is only displayed when the proof
     action list becomes empty, to avoid a confusing rapidly changing
     output that slows down processing.

     After processing the current output, the last step undertaken by
     the filter is to send the next command from the queue.


File: PG-adapting.info,  Node: Debugging,  Prev: Proof shell mode,  Up: Internals of Proof General

14.7 Debugging
==============

To debug Proof General, it may be helpful to set the configuration
variable `proof-general-debug'.

 -- User Option: proof-general-debug
     Non-nil to run Proof General in debug mode.
     This changes some behaviour (e.g. markup stripping) and displays
     debugging messages in the response buffer.  To avoid erasing
     messages shortly after they're printed, set
     ``proof-tidy-response'' to nil.  This is only useful for PG
     developers.

     The default value is `nil'.

For more information about debugging Emacs lisp, consult the Emacs Lisp
Reference Manual.  I recommend using the source-level debugger `edebug'.


File: PG-adapting.info,  Node: Plans and Ideas,  Next: Demonstration Instantiations,  Prev: Internals of Proof General,  Up: Top

Appendix A Plans and Ideas
**************************

This appendix contains some tentative plans and ideas for improving
Proof General.

This appendix is no longer extended: instead we keep a list of Proof
General projects on the web, and forthcoming plans and ideas in the
`TODO' and `todo' files included in the ordinary and developers PG
distributions, respectively.  Once the items mentioned below are
implemented, they will be removed from here.

Please send us contributions to our wish lists, or better still, an
offer to implement something from them!

* Menu:

* Proof by pointing and similar features::
* Granularity of atomic command sequences::
* Browser mode for script files and theories::


File: PG-adapting.info,  Node: Proof by pointing and similar features,  Next: Granularity of atomic command sequences,  Up: Plans and Ideas

A.1 Proof by pointing and similar features
==========================================

This is a note by David Aspinall about proof by pointing and similar
features.

Proof General already supports proof by pointing, and experimental
support is provided in LEGO.  We would like to extend this support to
other proof assistants.  Unfortunately, proof by pointing requires
rather heavy support from the proof assistant.  There are two aspects to
the support:
   * term structure mark-up

   * proof by pointing command generation
Term structure mark-up is useful in itself: it allows the user to
explore the structure of a term using the mouse (the smallest
subexpression that the mouse is over is highlighted), and easily copy
subterms from the output to a proof script.

Command generation for proof by pointing is usually specific to a
particular logic in use, if we hope to generate a good proof command
unambiguously for any particular click. However, Proof General could
easily be generalised to offer the user a context-sensitive choice of
next commands to apply, which may be more useful in practice, and a
worthy addition to Proof General.

Implementors of new proof assistants should be encouraged to consider
supporting term-structure mark up from the start.  Command generation
should be something that the logic-implementor can specify in some way.

Of the supported provers, we can certainly hope for proof-by-pointing
support from Coq, since the CtCoq proof-by-pointing code has been moved
into the Coq kernel lately.  I hope the Coq community can encourage
somebody to do this.


File: PG-adapting.info,  Node: Granularity of atomic command sequences,  Next: Browser mode for script files and theories,  Prev: Proof by pointing and similar features,  Up: Plans and Ideas

A.2 Granularity of atomic command sequences
===========================================

This is a proposal by Thomas Kleymann for generalising the way Proof
General handles sequences of proof commands (see Goal-save sequences in
the user manual), particularly to make retraction more flexible.

The blue region of a script buffer contains the initial segment of the
proof script which has been processed successfully. It consists of
atomic sequences of commands (ACS). Retraction is supported to the
beginning of every ACS. By default, every command is an ACS. But the
granularity of atomicity should be able to be adjusted.

This is essential when arbitrary retraction is not supported. Usually,
after a theorem has been proved, one may only retract to the start of
the goal. One needs to mark the proof of the theorem as an ACS. At
present, support for goal-save sequences (see Goal-save sequences in
the user manual), has been hard wired. No other ACS are currently
supported. We propose the following to overcome this deficiency:

`proof-atomic-sequents-list'
     is a list of instructions for setting up ACSs. Each instruction is
     a list of the form `(END START &optional FORGET-COMMAND)'. END is
     a regular expression to recognise the last command in an ACS.
     START is a function. Its input is the last command of an ACS. Its
     output is a regular expression to recognise the first command of
     the ACS. It is evaluated once and, starting with the command
     matched by END, the output is successively matched against
     previously processed commands until a match occurs (or the
     beginning of the current buffer is reached). The region determined
     by (START,END) is locked as an ACS. Optionally, the ACS is
     annotated with the actual command to retract the ACS. This is
     computed by applying FORGET-COMMAND to the first and last command
     of the ACS.

     For convenience one might also want to allow START to be the
     symbol `t' as a convenient short-hand for `'(lambda (str) ".")'
     which always matches.


File: PG-adapting.info,  Node: Browser mode for script files and theories,  Prev: Granularity of atomic command sequences,  Up: Plans and Ideas

A.3 Browser mode for script files and theories
==============================================

This is a proposal by David Aspinall for a browser window.

A browser window should provide support for browsing script files and
theories.  We should be able to inspect data in varying levels of
detail, perhaps using outlining mechanisms.  For theories, it would be
nice to query the running proof assistant.  This may require support
from the assistant in the form of output which has been specially
marked-up with an SGML like syntax, for example.

A browser would be useful to:
   * Provide impoverished proof assistants with a browser

   * Extend the uniform interface of Proof General to theory browsing

   * Interact closely with proof script writing
The last point is the most important. We should be able to integrate a
search mechanism for proofs of similar theorems, theorems containing
particular constants, etc.


File: PG-adapting.info,  Node: Demonstration Instantiations,  Next: Function Index,  Prev: Plans and Ideas,  Up: Top

Appendix B Demonstration Instantiations
***************************************

This appendix contains the code for the two demonstration
instantiations of Proof General, for Isabelle.

These instantiations make an almost-bare minimum of settings to get
things working.  To add embellishments, you should refer to the
instantiations for other systems distributed with Proof General.

* Menu:

* demoisa-easy.el::
* demoisa.el::


File: PG-adapting.info,  Node: demoisa-easy.el,  Next: demoisa.el,  Up: Demonstration Instantiations

B.1 demoisa-easy.el
===================

     ;; demoisa-easy.el Example Proof General instance for Isabelle
     ;;
     ;; Copyright (C) 1999 LFCS Edinburgh.
     ;;
     ;; Author: David Aspinall <David.Aspinall@ed.ac.uk>
     ;;
     ;; PG-adapting.texi,v 12.6 2012/05/29 14:53:59 tews Exp
     ;;
     ;; This is an alternative version of demoisa.el which uses the
     ;; proof-easy-config macro to do the work of declaring derived modes,
     ;; etc.
     ;;
     ;; See demoisa.el and the Proof General manual for more documentation.
     ;;
     ;; To test this file you must rename it demoisa.el.
     ;;

     (require 'proof-easy-config)            ; easy configure mechanism

     (proof-easy-config
      'demoisa "Isabelle Demo"
      proof-prog-name		 "isabelle"
      proof-terminal-string           ";"
      proof-script-comment-start             "(*"
      proof-script-comment-end               "*)"
      proof-goal-command-regexp       "^Goal"
      proof-save-command-regexp       "^qed"
      proof-goal-with-hole-regexp     "qed_goal \"\\(\\(.*\\)\\)\""
      proof-save-with-hole-regexp     "qed \"\\(\\(.*\\)\\)\""
      proof-non-undoables-regexp      "undo\\|back"
      proof-goal-command              "Goal \"%s\";"
      proof-save-command              "qed \"%s\";"
      proof-kill-goal-command         "Goal \"PROP no_goal_set\";"
      proof-showproof-command         "pr()"
      proof-undo-n-times-cmd          "pg_repeat undo %s;"
      proof-auto-multiple-files       t
      proof-shell-cd-cmd              "cd \"%s\""
      proof-shell-interrupt-regexp    "Interrupt"
      proof-shell-start-goals-regexp  "Level [0-9]"
      proof-shell-end-goals-regexp    "val it"
      proof-shell-quit-cmd            "quit();"
      proof-assistant-home-page
      "http://www.cl.cam.ac.uk/Research/HVG/Isabelle/"
      proof-shell-annotated-prompt-regexp
      "^\\(val it = () : unit\n\\)?ML>? "
      proof-shell-error-regexp
      "\\*\\*\\*\\|^.*Error:\\|^uncaught exception \\|^Exception- "
      proof-shell-init-cmd
      "fun pg_repeat f 0 = () | pg_repeat f n = (f(); pg_repeat f (n-1));"
      proof-shell-proof-completed-regexp "^No subgoals!"
      proof-shell-eager-annotation-start
      "^\\[opening \\|^###\\|^Reading")

     (provide 'demoisa)


File: PG-adapting.info,  Node: demoisa.el,  Prev: demoisa-easy.el,  Up: Demonstration Instantiations

B.2 demoisa.el
==============

     ;; demoisa.el Example Proof General instance for Isabelle
     ;;
     ;; Copyright (C) 1999 LFCS Edinburgh.
     ;;
     ;; Author: David Aspinall <David.Aspinall@ed.ac.uk>
     ;;
     ;; PG-adapting.texi,v 12.6 2012/05/29 14:53:59 tews Exp
     ;;
     ;; =================================================================
     ;;
     ;; See README in this directory for an introduction.
     ;;
     ;; Basic configuration is controlled by one line in `proof-site.el'.
     ;; It has this line in proof-assistant-table:
     ;;
     ;;     (demoisa "Isabelle Demo"	"\\.ML$")
     ;;
     ;; From this it loads this file "demoisa/demoisa.el" whenever
     ;; a .ML file is visited, and sets the mode to `demoisa-mode'
     ;; (defined below).
     ;;
     ;; I've called this instance "Isabelle Demo Proof General" just to
     ;; avoid confusion with the real "Isabelle Proof General" in case the
     ;; demo gets loaded by accident.
     ;;
     ;; To make the line above take precedence over the real Isabelle mode
     ;; later in the table, set PROOFGENERAL_ASSISTANTS=demoisa in the
     ;; shell before starting Emacs  (or customize proof-assistants).
     ;;


     (require 'proof)			; load generic parts


     ;; ======== User settings for Isabelle ========
     ;;
     ;; Defining variables using customize is pretty easy.
     ;; You should do it at least for your prover-specific user options.
     ;;
     ;; proof-site provides us with two customization groups
     ;; automatically:  (based on the name of the assistant)
     ;;
     ;; 'isabelledemo        -  User options for Isabelle Demo Proof General
     ;; 'isabelledemo-config -  Configuration of Isabelle Proof General
     ;;			   (constants, but may be nice to tweak)
     ;;
     ;; The first group appears in the menu
     ;;   ProofGeneral -> Advanced -> Customize -> Isabelledemo
     ;; The second group appears in the menu:
     ;;   ProofGeneral -> Internals -> Isabelledemo config
     ;;

     (defcustom isabelledemo-prog-name "isabelle"
       "*Name of program to run Isabelle."
       :type 'file
       :group 'isabelledemo)

     (defcustom isabelledemo-web-page
       "http://www.cl.cam.ac.uk/Research/HVG/isabelle.html"
       "URL of web page for Isabelle."
       :type 'string
       :group 'isabelledemo-config)


     ;;
     ;; ======== Configuration of generic modes ========
     ;;

     (defun demoisa-config ()
       "Configure Proof General scripting for Isabelle."
       (setq
        proof-terminal-string	";"
        proof-script-comment-start	"(*"
        proof-script-comment-end	"*)"
        proof-goal-command-regexp    "^Goal"
        proof-save-command-regexp    "^qed"
        proof-goal-with-hole-regexp  "qed_goal \"\\(\\(.*\\)\\)\""
        proof-save-with-hole-regexp  "qed \"\\(\\(.*\\)\\)\""
        proof-non-undoables-regexp   "undo\\|back"
        proof-undo-n-times-cmd	"pg_repeat undo %s;"
        proof-showproof-command	"pr()"
        proof-goal-command		"Goal \"%s\";"
        proof-save-command		"qed \"%s\";"
        proof-kill-goal-command	"Goal \"PROP no_goal_set\";"
        proof-assistant-home-page	isabelledemo-web-page
        proof-auto-multiple-files    t))


     (defun demoisa-shell-config ()
       "Configure Proof General shell for Isabelle."
       (setq
        proof-shell-annotated-prompt-regexp   "^\\(val it = () : unit\n\\)?ML>? "
        proof-shell-cd-cmd			"cd \"%s\""
        proof-shell-interrupt-regexp         "Interrupt"
        proof-shell-error-regexp		"\\*\\*\\*\\|^.*Error:\\|^uncaught exception \\|^Exception- "
        proof-shell-start-goals-regexp	"Level [0-9]"
        proof-shell-end-goals-regexp		"val it"
        proof-shell-proof-completed-regexp   "^No subgoals!"
        proof-shell-eager-annotation-start   "^\\[opening \\|^###\\|^Reading"
        proof-shell-init-cmd  ; define a utility function, in a lib somewhere?
        "fun pg_repeat f 0 = ()
           | pg_repeat f n = (f(); pg_repeat f (n-1));"
        proof-shell-quit-cmd			"quit();"))



     ;;
     ;; ======== Defining the derived modes ========
     ;;

     ;; The name of the script mode is always <proofsym>-script,
     ;; but the others can be whatever you like.
     ;;
     ;; The derived modes set the variables, then call the
     ;; <mode>-config-done function to complete configuration.

     (define-derived-mode demoisa-mode proof-mode
         "Isabelle Demo script" nil
         (demoisa-config)
         (proof-config-done))

     (define-derived-mode demoisa-shell-mode proof-shell-mode
        "Isabelle Demo shell" nil
        (demoisa-shell-config)
        (proof-shell-config-done))

     (define-derived-mode demoisa-response-mode proof-response-mode
       "Isabelle Demo response" nil
       (proof-response-config-done))

     (define-derived-mode demoisa-goals-mode proof-goals-mode
       "Isabelle Demo goals" nil
       (proof-goals-config-done))

     ;; The response buffer and goals buffer modes defined above are
     ;; trivial.  In fact, we don't need to define them at all -- they
     ;; would simply default to "proof-response-mode" and "pg-goals-mode".

     ;; A more sophisticated instantiation might set font-lock-keywords to
     ;; add highlighting, or some of the proof by pointing markup
     ;; configuration for the goals buffer.

     (provide 'demoisa)


File: PG-adapting.info,  Node: Function Index,  Next: Variable Index,  Prev: Demonstration Instantiations,  Up: Top

Function and Command Index
**************************

 [index ]
* Menu:

* defpgcustom:                           Configuration variable mechanisms.
                                                              (line  24)
* defpgdefault <1>:                      Configuration variable mechanisms.
                                                              (line  42)
* defpgdefault:                          Default values for generic settings.
                                                              (line  14)
* proof-activate-scripting:              Proof script mode.   (line  79)
* proof-add-completions:                 Completions.         (line  30)
* proof-ass:                             Configuration variable mechanisms.
                                                              (line  60)
* proof-ass-sym:                         Configuration variable mechanisms.
                                                              (line  65)
* proof-ass-symv:                        Configuration variable mechanisms.
                                                              (line  70)
* proof-assert-until-point:              Proof script mode.   (line 193)
* proof-complete-buffer-atomic:          Proof script mode.   (line  38)
* proof-deactivate-scripting:            Proof script mode.   (line 105)
* proof-define-assistant-command:        Useful functions and macros.
                                                              (line  68)
* proof-define-assistant-command-witharg: Useful functions and macros.
                                                              (line  72)
* proof-definvisible:                    Useful functions and macros.
                                                              (line  60)
* proof-defshortcut:                     Useful functions and macros.
                                                              (line  24)
* proof-deftoggle:                       Configuration variable mechanisms.
                                                              (line 112)
* proof-extend-queue:                    Proof shell mode.    (line 168)
* proof-format-filename:                 Useful functions and macros.
                                                              (line  77)
* proof-generic-count-undos:             Configuring undo behaviour.
                                                              (line  46)
* proof-generic-find-and-forget:         Configuring undo behaviour.
                                                              (line  72)
* proof-generic-state-preserving-p:      Safe (state-preserving) commands.
                                                              (line  22)
* proof-grab-lock:                       Proof shell mode.    (line 234)
* proof-init-segmentation:               Proof script mode.   (line  30)
* proof-insert:                          Useful functions and macros.
                                                              (line  18)
* proof-looking-at-syntactic-context:    Recognizing commands and comments.
                                                              (line 125)
* proof-register-possibly-new-processed-file: Proof script mode.
                                                              (line  56)
* proof-release-lock:                    Proof shell mode.    (line 239)
* proof-restart-buffers:                 Proof script mode.   (line 233)
* proof-retract-until-point:             Proof script mode.   (line 200)
* proof-script-generic-parse-cmdend:     Proof script mode.   (line 161)
* proof-script-generic-parse-cmdstart:   Proof script mode.   (line 165)
* proof-script-generic-parse-sexp:       Proof script mode.   (line 169)
* proof-script-remove-all-spans-and-deactivate: Proof script mode.
                                                              (line 242)
* proof-semis-to-vanillas:               Proof script mode.   (line 173)
* proof-set-value:                       Configuration variable mechanisms.
                                                              (line  98)
* proof-shell-bail-out:                  Proof shell mode.    (line 137)
* proof-shell-exec-loop:                 Proof shell mode.    (line 180)
* proof-shell-exit:                      Proof shell mode.    (line 119)
* proof-shell-filter:                    Proof shell mode.    (line 422)
* proof-shell-filter-manage-output:      Proof shell mode.    (line 466)
* proof-shell-handle-delayed-output:     Proof shell mode.    (line 357)
* proof-shell-handle-immediate-output:   Proof shell mode.    (line 334)
* proof-shell-insert:                    Proof shell mode.    (line 204)
* proof-shell-invisible-command:         Useful functions and macros.
                                                              (line  36)
* proof-shell-kill-function:             Proof shell mode.    (line 113)
* proof-shell-process-urgent-message:    Proof shell mode.    (line 406)
* proof-shell-restart:                   Proof shell mode.    (line 144)
* proof-shell-start:                     Proof shell mode.    (line  97)
* proof-tree-external-display-toggle:    Guards.              (line  39)
* proof-tree-handle-delayed-output:      Urgent and Delayed Actions.
                                                              (line  45)
* proof-tree-urgent-action:              Urgent and Delayed Actions.
                                                              (line  16)
* proof-zap-commas:                      Configuring Font Lock.
                                                              (line  51)


File: PG-adapting.info,  Node: Variable Index,  Next: Concept Index,  Prev: Function Index,  Up: Top

Variable and User Option Index
******************************

 [index ]
* Menu:

* comment-quote-nested:                  Configuring Editing Syntax.
                                                              (line  35)
* imenu-generic-expression:              Recognizing other elements.
                                                              (line  17)
* outline-heading-end-regexp:            Configuring Editing Syntax.
                                                              (line  45)
* outline-regexp:                        Configuring Editing Syntax.
                                                              (line  40)
* PA-completion-table:                   Completions.         (line  22)
* PA-help-menu-entries:                  Menu configuration.  (line  18)
* PA-menu-entries:                       Menu configuration.  (line  13)
* PA-prog-args:                          Proof shell commands.
                                                              (line  20)
* PA-prog-env:                           Proof shell commands.
                                                              (line  33)
* PA-toolbar-entries:                    Toolbar configuration.
                                                              (line  31)
* pbp-goal-command:                      Goals Buffer Settings.
                                                              (line  16)
* pbp-hyp-command:                       Goals Buffer Settings.
                                                              (line  19)
* pg-after-fontify-output-hook:          Configuring Font Lock.
                                                              (line  65)
* pg-before-fontify-output-hook:         Configuring Font Lock.
                                                              (line  58)
* pg-goals-change-goal:                  Goals Buffer Settings.
                                                              (line  13)
* pg-goals-error-regexp:                 Goals Buffer Settings.
                                                              (line  23)
* pg-subterm-anns-use-stack:             Proof shell mode.    (line  87)
* pg-subterm-end-char:                   Goals Buffer Settings.
                                                              (line  65)
* pg-subterm-first-special-char:         Settings for matching various output from proof process.
                                                              (line  13)
* pg-subterm-sep-char:                   Goals Buffer Settings.
                                                              (line  47)
* pg-subterm-start-char:                 Goals Buffer Settings.
                                                              (line  37)
* pg-topterm-goalhyplit-fn:              Configuring undo behaviour.
                                                              (line  93)
* pg-topterm-regexp:                     Goals Buffer Settings.
                                                              (line  51)
* proof-action-list:                     Proof shell mode.    (line  49)
* proof-activate-scripting-hook:         Activate scripting hook.
                                                              (line   7)
* proof-assistant-home-page:             Settings for generic user-level commands.
                                                              (line   7)
* proof-assistant-table:                 Overview of adding a new prover.
                                                              (line  34)
* proof-assistants:                      Proof General site configuration.
                                                              (line  36)
* proof-atomic-sequents-list:            Granularity of atomic command sequences.
                                                              (line  23)
* proof-auto-multiple-files:             Automatic multiple files.
                                                              (line   9)
* proof-buffer-type:                     Global variables.    (line  22)
* proof-cannot-reopen-processed-files <1>: Handling Multiple Files.
                                                              (line  54)
* proof-cannot-reopen-processed-files:   Settings for matching urgent messages from proof process.
                                                              (line 221)
* proof-case-fold-search:                Recognizing commands and comments.
                                                              (line 111)
* proof-completed-proof-behaviour:       Recognizing proofs.  (line  62)
* proof-context-command:                 Settings for generic user-level commands.
                                                              (line  11)
* proof-count-undos-fn:                  Configuring undo behaviour.
                                                              (line  36)
* proof-electric-terminator-noterminator: Recognizing commands and comments.
                                                              (line  29)
* proof-find-and-forget-fn:              Configuring undo behaviour.
                                                              (line  56)
* proof-find-theorems-command:           Settings for generic user-level commands.
                                                              (line  35)
* proof-forget-id-command:               Configuring undo behaviour.
                                                              (line  85)
* proof-general-debug:                   Debugging.           (line  10)
* proof-general-home-page:               Global Constants.    (line  14)
* proof-general-name:                    Global Constants.    (line  11)
* proof-general-version:                 Proof General site configuration.
                                                              (line  61)
* proof-goal-command:                    Settings for generic user-level commands.
                                                              (line  22)
* proof-goal-command-p:                  Recognizing proofs.  (line  23)
* proof-goal-command-regexp:             Recognizing proofs.  (line  17)
* proof-goal-with-hole-regexp <1>:       Recognizing other elements.
                                                              (line   6)
* proof-goal-with-hole-regexp:           Recognizing proofs.  (line  32)
* proof-goal-with-hole-result <1>:       Recognizing other elements.
                                                              (line   6)
* proof-goal-with-hole-result:           Recognizing proofs.  (line  42)
* proof-goals-buffer:                    Global variables.    (line  19)
* proof-goals-font-lock-keywords:        Configuring Font Lock.
                                                              (line  29)
* proof-home-directory:                  Proof General site configuration.
                                                              (line  14)
* proof-ignore-for-undo-count:           Configuring undo behaviour.
                                                              (line  30)
* proof-images-directory:                Proof General site configuration.
                                                              (line  24)
* proof-included-files-list <1>:         Global variables.    (line  26)
* proof-included-files-list <2>:         Handling Multiple Files.
                                                              (line  25)
* proof-included-files-list:             Settings for matching urgent messages from proof process.
                                                              (line 177)
* proof-info-command:                    Settings for generic user-level commands.
                                                              (line  14)
* proof-info-directory:                  Proof General site configuration.
                                                              (line  27)
* proof-kill-goal-command:               Configuring undo behaviour.
                                                              (line 104)
* proof-locked-span:                     Proof script mode.   (line  15)
* proof-marker:                          Proof shell mode.    (line  46)
* proof-nested-goals-history-p:          Nested proofs.       (line  14)
* proof-nested-undo-regexp:              Nested proofs.       (line  24)
* proof-no-fully-processed-buffer:       Completely asserted buffers.
                                                              (line  23)
* proof-non-undoables-regexp:            Configuring undo behaviour.
                                                              (line  10)
* proof-prog-name:                       Proof shell commands.
                                                              (line  10)
* proof-queue-span:                      Proof script mode.   (line  21)
* proof-really-save-command-p:           Recognizing proofs.  (line  85)
* proof-response-buffer:                 Global variables.    (line  16)
* proof-response-font-lock-keywords:     Configuring Font Lock.
                                                              (line  36)
* proof-running-on-win32:                Useful variables.    (line  13)
* proof-save-command:                    Settings for generic user-level commands.
                                                              (line  28)
* proof-save-command-regexp:             Recognizing proofs.  (line  50)
* proof-save-with-hole-regexp:           Recognizing proofs.  (line  53)
* proof-script-buffer:                   Global variables.    (line  10)
* proof-script-command-end-regexp:       Recognizing commands and comments.
                                                              (line  54)
* proof-script-command-start-regexp:     Recognizing commands and comments.
                                                              (line  44)
* proof-script-comment-end:              Recognizing commands and comments.
                                                              (line  93)
* proof-script-comment-end-regexp:       Recognizing commands and comments.
                                                              (line 104)
* proof-script-comment-start:            Recognizing commands and comments.
                                                              (line  76)
* proof-script-comment-start-regexp:     Recognizing commands and comments.
                                                              (line  86)
* proof-script-font-lock-keywords:       Configuring Font Lock.
                                                              (line  22)
* proof-script-imenu-generic-expression: Recognizing other elements.
                                                              (line  11)
* proof-script-sexp-commands:            Recognizing commands and comments.
                                                              (line  33)
* proof-script-syntax-table-entries:     Configuring Editing Syntax.
                                                              (line  16)
* proof-shell-annotated-prompt-regexp:   Settings for matching various output from proof process.
                                                              (line  19)
* proof-shell-assumption-regexp:         Settings for matching various output from proof process.
                                                              (line 113)
* proof-shell-auto-terminate-commands:   Proof shell commands.
                                                              (line  42)
* proof-shell-buffer:                    Global variables.    (line  13)
* proof-shell-busy:                      Proof shell mode.    (line  28)
* proof-shell-cd-cmd:                    Proof shell commands.
                                                              (line  79)
* proof-shell-clear-goals-regexp:        Settings for matching urgent messages from proof process.
                                                              (line  83)
* proof-shell-clear-response-regexp:     Settings for matching urgent messages from proof process.
                                                              (line  72)
* proof-shell-compute-new-files-list <1>: Handling Multiple Files.
                                                              (line  54)
* proof-shell-compute-new-files-list:    Settings for matching urgent messages from proof process.
                                                              (line 208)
* proof-shell-delayed-output-end:        Proof shell mode.    (line 326)
* proof-shell-delayed-output-flags:      Proof shell mode.    (line 330)
* proof-shell-delayed-output-start:      Proof shell mode.    (line 322)
* proof-shell-eager-annotation-end <1>:  Handling Multiple Files.
                                                              (line 112)
* proof-shell-eager-annotation-end:      Settings for matching urgent messages from proof process.
                                                              (line  50)
* proof-shell-eager-annotation-start <1>: Handling Multiple Files.
                                                              (line 112)
* proof-shell-eager-annotation-start:    Settings for matching urgent messages from proof process.
                                                              (line  19)
* proof-shell-eager-annotation-start-length: Settings for matching urgent messages from proof process.
                                                              (line  41)
* proof-shell-end-goals-regexp:          Settings for matching various output from proof process.
                                                              (line 100)
* proof-shell-error-or-interrupt-seen:   Global variables.    (line  54)
* proof-shell-error-regexp:              Settings for matching various output from proof process.
                                                              (line  32)
* proof-shell-filename-escapes:          Hooks and other settings.
                                                              (line   7)
* proof-shell-handle-error-or-interrupt-hook: Hooks and other settings.
                                                              (line  25)
* proof-shell-handle-output-system-specific: Hooks and other settings.
                                                              (line  45)
* proof-shell-inform-file-processed-cmd: Proof shell commands.
                                                              (line 118)
* proof-shell-inform-file-retracted-cmd: Proof shell commands.
                                                              (line 139)
* proof-shell-init-cmd:                  Proof shell commands.
                                                              (line  63)
* proof-shell-insert-hook:               Script input to the shell.
                                                              (line  24)
* proof-shell-interactive-prompt-regexp: Settings for matching urgent messages from proof process.
                                                              (line  94)
* proof-shell-interrupt-regexp:          Settings for matching various output from proof process.
                                                              (line  51)
* proof-shell-last-output:               Proof shell mode.    (line 278)
* proof-shell-last-output-kind:          Proof shell mode.    (line 282)
* proof-shell-last-prompt:               Proof shell mode.    (line 273)
* proof-shell-pre-interrupt-hook:        Hooks and other settings.
                                                              (line  40)
* proof-shell-pre-sync-init-cmd:         Proof shell commands.
                                                              (line  50)
* proof-shell-process-connection-type:   Hooks and other settings.
                                                              (line  21)
* proof-shell-process-file <1>:          Handling Multiple Files.
                                                              (line  54)
* proof-shell-process-file:              Settings for matching urgent messages from proof process.
                                                              (line 178)
* proof-shell-proof-completed:           Global variables.    (line  49)
* proof-shell-proof-completed-regexp:    Settings for matching various output from proof process.
                                                              (line  76)
* proof-shell-quit-cmd:                  Proof shell commands.
                                                              (line  76)
* proof-shell-restart-cmd:               Proof shell commands.
                                                              (line  73)
* proof-shell-result-end:                Goals Buffer Settings.
                                                              (line  32)
* proof-shell-result-start:              Goals Buffer Settings.
                                                              (line  26)
* proof-shell-retract-files-regexp <1>:  Handling Multiple Files.
                                                              (line  54)
* proof-shell-retract-files-regexp:      Settings for matching urgent messages from proof process.
                                                              (line 197)
* proof-shell-set-elisp-variable-regexp: Settings for matching urgent messages from proof process.
                                                              (line 122)
* proof-shell-silent-threshold:          Proof shell commands.
                                                              (line 109)
* proof-shell-start-goals-regexp:        Settings for matching various output from proof process.
                                                              (line  88)
* proof-shell-start-silent-cmd:          Proof shell commands.
                                                              (line  94)
* proof-shell-stop-silent-cmd:           Proof shell commands.
                                                              (line 102)
* proof-shell-strip-crs-from-input:      Script input to the shell.
                                                              (line  14)
* proof-shell-strip-crs-from-output:     Proof shell mode.    (line 267)
* proof-shell-syntax-table-entries:      Configuring Editing Syntax.
                                                              (line  25)
* proof-shell-theorem-dependency-list-regexp: Settings for matching urgent messages from proof process.
                                                              (line 159)
* proof-shell-trace-output-regexp:       Settings for matching urgent messages from proof process.
                                                              (line 107)
* proof-shell-truncate-before-error:     Settings for matching various output from proof process.
                                                              (line  64)
* proof-shell-urgent-message-marker:     Proof shell mode.    (line 402)
* proof-showproof-command:               Settings for generic user-level commands.
                                                              (line  19)
* proof-splash-contents:                 Splash Screen Settings.
                                                              (line  15)
* proof-splash-time:                     Splash Screen Settings.
                                                              (line   9)
* proof-state-preserving-p:              Safe (state-preserving) commands.
                                                              (line  11)
* proof-terminal-string:                 Recognizing commands and comments.
                                                              (line  20)
* proof-tokens-activate-command:         Configuring Tokens.  (line  19)
* proof-tokens-deactivate-command:       Configuring Tokens.  (line  24)
* proof-tokens-extra-modes:              Configuring Tokens.  (line  35)
* proof-toolbar-entries-default:         Toolbar configuration.
                                                              (line  22)
* proof-tree-configured:                 Guards.              (line  10)
* proof-tree-existentials-alist:         Organization of the Code.
                                                              (line  49)
* proof-tree-existentials-alist-history: Organization of the Code.
                                                              (line  65)
* proof-tree-external-display:           Guards.              (line  15)
* proof-tree-sequent-hash:               Organization of the Code.
                                                              (line  34)
* proof-undo-n-times-cmd:                Configuring undo behaviour.
                                                              (line  19)
* proof-universal-keys:                  Global Constants.    (line  19)


File: PG-adapting.info,  Node: Concept Index,  Prev: Variable Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* ACS (Atomic Command Sequence):         Granularity of atomic command sequences.
                                                               (line  6)
* comint-mode:                           Proof shell mode.     (line  6)
* configuration:                         Configuration variable mechanisms.
                                                               (line  6)
* conventions:                           Configuration variable mechanisms.
                                                               (line  6)
* debugging:                             Debugging.            (line  6)
* extents:                               Spans.                (line  6)
* font lock:                             Configuring Font Lock.
                                                               (line  6)
* Future:                                Future.               (line  6)
* installation directories:              Proof General site configuration.
                                                               (line  6)
* mode stub:                             Proof General site configuration.
                                                               (line 29)
* Multiple files:                        Handling Multiple Files.
                                                               (line  6)
* overlays:                              Spans.                (line  6)
* proof by pointing:                     Proof by pointing and similar features.
                                                               (line  6)
* Proof General Kit:                     Future.               (line  6)
* proof shell mode:                      Proof shell mode.     (line  6)
* scomint-mode:                          Proof shell mode.     (line  6)
* settings:                              Configuration variable mechanisms.
                                                               (line  6)
* site configuration:                    Proof General site configuration.
                                                               (line  6)
* spans:                                 Spans.                (line  6)
* syntax table:                          Configuring Editing Syntax.
                                                               (line  6)
* Tokens:                                Configuring Tokens.   (line  6)
* Unicode Tokens:                        Configuring Tokens.   (line  6)
* user options:                          Configuration variable mechanisms.
                                                               (line  6)
* variables:                             Global variables.     (line  6)



Tag Table:
Node: Top254
Node: Introduction1317
Node: Future3040
Node: Credits4633
Node: Beginning with a New Prover4978
Node: Overview of adding a new prover7025
Node: Demonstration instance and easy configuration10409
Node: Major modes used by Proof General13824
Node: Menus and Toolbar and User-level Commands15564
Node: Settings for generic user-level commands16232
Node: Menu configuration17809
Node: Toolbar configuration18772
Node: Proof Script Settings20999
Node: Recognizing commands and comments21731
Node: Recognizing proofs27585
Node: Recognizing other elements31696
Node: Configuring undo behaviour34058
Node: Nested proofs39113
Node: Safe (state-preserving) commands40826
Node: Activate scripting hook41798
Node: Automatic multiple files42801
Node: Completely asserted buffers43791
Node: Completions45364
Node: Proof Shell Settings46829
Node: Proof shell commands48196
Node: Script input to the shell55472
Node: Settings for matching various output from proof process58795
Node: Settings for matching urgent messages from proof process64161
Node: Hooks and other settings75004
Node: Goals Buffer Settings77974
Node: Splash Screen Settings80523
Node: Global Constants81322
Node: Handling Multiple Files82116
Node: Configuring Editing Syntax90165
Node: Configuring Font Lock92177
Node: Configuring Tokens95501
Node: Configuring Proof-Tree Visualization97492
Node: Prerequisites98149
Node: Proof-Tree Display Internals101032
Node: Organization of the Code101693
Node: Communication105860
Node: Guards107073
Node: Urgent and Delayed Actions109190
Node: Full Annotation111700
Node: Configuring Prooftree for a New Proof Assistant112363
Node: Proof Tree Elisp configuration112845
Node: Prooftree Adaption113795
Node: Writing More Lisp Code114573
Node: Default values for generic settings115341
Node: Adding prover-specific configurations116471
Node: Useful variables117856
Node: Useful functions and macros118451
Node: Internals of Proof General122382
Node: Spans123325
Node: Proof General site configuration123691
Node: Configuration variable mechanisms126429
Node: Global variables131783
Node: Proof script mode134119
Node: Proof shell mode145422
Node: Debugging166336
Node: Plans and Ideas167103
Node: Proof by pointing and similar features167942
Node: Granularity of atomic command sequences169678
Node: Browser mode for script files and theories171937
Node: Demonstration Instantiations173007
Node: demoisa-easy.el173557
Node: demoisa.el175955
Node: Function Index181455
Node: Variable Index187171
Node: Concept Index208107

End Tag Table
